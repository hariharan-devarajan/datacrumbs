
        #include <linux/sched.h>
        #include <uapi/linux/limits.h>
        #include <uapi/linux/ptrace.h>
        
        struct fn_key_t {
            u64 id;
        };
        struct fn_t {
            u64 ip;
            u64 ts;
        };
        struct file_t {
          u64 id;
          int fd;  
        };
        struct filename_t {
            char fname[256];
        };
        
        BPF_HASH(pid_map, u32, u64); // map for apps to collect data
        BPF_HASH(fn_pid_map, struct fn_key_t, struct fn_t); // collect start time and ip for apps
        BPF_HASH(file_hash, u64, struct filename_t, 10240);
        BPF_HASH(latest_hash, struct fn_key_t, u64);
        BPF_HASH(latest_fd, u64, int);
        BPF_HASH(fd_hash, struct file_t, u64);
        BPF_HASH(pid_hash, u64, u64);
        
        BPF_RINGBUF_OUTPUT(events, 1 << 16); // emit events to python
        
        static u64 get_hash(unsigned char *str, u64 len) {
            u64 hash = 5381;
            int c = *str;
            int count = 0;
            while (count < len && c) {
                hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
                c = *str++;
                count++;
            }
            return hash;
        }
        /*static u64 get_hash(u64 id) {
            u64 first_hash = 1;
            u64* hash_value = pid_hash.lookup_or_init(&id, &first_hash);
            (*hash_value)++;
            return *hash_value;
        }*/
        
        struct generic_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
        };         
        int trace_generic_entry(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
            return 0;
        }

        int trace_generic_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct generic_event_t stats_key_v = {};
            struct generic_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 100001;
            stats_key->ip = fn->ip;
                    
                        
            struct generic_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
              
            // bpf_trace_printk("Submitting GEN TRACE IP \%d",fn->ip);      
            
            events.ringbuf_output(&stats_key_v, sizeof(struct generic_event_t), 0);
        
            return 0;
        }
                
        int user_generic_entry(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
            return 0;
        }

        int user_generic_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct generic_event_t stats_key_v = {};
            struct generic_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 100002;
            stats_key->ip = fn->ip;
                    
                        
            struct generic_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
              
            // bpf_trace_printk("Submitting GEN TRACE IP \%d",fn->ip);      
            
            events.ringbuf_output(&stats_key_v, sizeof(struct generic_event_t), 0);
        
            return 0;
        }
        
        int syscall__trace_entry_generic(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
           
            return 0;
        }

        int sys__trace_exit_generic(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct generic_event_t stats_key_v = {};
            struct generic_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 100000;
            stats_key->ip = fn->ip;
        
                        
            struct generic_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            // bpf_trace_printk("Submitting GEN SYS IP \%d",fn->ip);
            
            events.ringbuf_output(&stats_key_v, sizeof(struct generic_event_t), 0);
        
            
        
            return 0;
        }
        
        int trace_datacrumbs_start(struct pt_regs *ctx) {
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = 0;
            u64* start_ts = pid_map.lookup(&pid);
            u64 tsp = bpf_ktime_get_ns();
            if (start_ts != 0)                                      
                tsp = *start_ts;
            else
                pid_map.update(&pid, &tsp);
            pid = id;
            bpf_trace_printk("Tracing PID \%d",pid);
            pid_map.update(&pid, &tsp);
            return 0;
        }
        int trace_datacrumbs_stop(struct pt_regs *ctx) {
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            bpf_trace_printk("Stop tracing PID \%d",pid);
            pid_map.delete(&pid);
            return 0;
        }
        
        
            struct sys_openat_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            
        };
        
        int syscall__trace_entry_openat(struct pt_regs *ctx , int dfd, const char *filename, int flags) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        struct filename_t fname_i;
                        u64 filename_len = sizeof(fname_i.fname);
                        int len = bpf_probe_read_user_str(&fname_i.fname, filename_len, filename);
                        //fname_i.fname[len-1] = '\0';
                        u64 filehash = get_hash(fname_i.fname, filename_len);
                        bpf_trace_printk("Hash value is %d for filename \%s",filehash,filename);
                        file_hash.update(&filehash, &fname_i);
                        latest_hash.update(&key, &filehash);
                           
            return 0;
        }

        int sys__trace_exit_openat(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_openat_event_t stats_key_v = {};
            struct sys_openat_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1;
            stats_key->ip = fn->ip;
        
            
                        u64* hash_ptr = latest_hash.lookup(&key);
                        if (hash_ptr != 0) {
                            stats_key->file_hash = *hash_ptr; 
                        }
                        
                        
            struct sys_openat_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                        if (hash_ptr != 0) {
                            int fd = PT_REGS_RC(ctx);
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = fd;
                            fd_hash.update(&file_key, hash_ptr);
                        }
                        
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_openat_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_read(struct pt_regs *ctx 
                        , int fd, void *data, u64 count
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_read(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_read_event_t stats_key_v = {};
            struct sys_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 2;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_read_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_write(struct pt_regs *ctx 
                        , int fd, const void *data, u64 count
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_write(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_write_event_t stats_key_v = {};
            struct sys_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 3;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_write_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            
        };
        
        int syscall__trace_entry_close(struct pt_regs *ctx 
                        , int fd
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_close(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_close_event_t stats_key_v = {};
            struct sys_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 4;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_close_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_fallocate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            
        };
        
        int syscall__trace_entry_fallocate(struct pt_regs *ctx 
                        , int fd, int mode, int offset, int len
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_fallocate(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_fallocate_event_t stats_key_v = {};
            struct sys_fallocate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 5;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_fallocate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_fallocate_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_fdatasync_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            
        };
        
        int syscall__trace_entry_fdatasync(struct pt_regs *ctx 
                        , int fd
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_fdatasync(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_fdatasync_event_t stats_key_v = {};
            struct sys_fdatasync_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 6;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_fdatasync_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_fdatasync_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_flock_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            
        };
        
        int syscall__trace_entry_flock(struct pt_regs *ctx 
                        , int fd, int cmd
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_flock(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_flock_event_t stats_key_v = {};
            struct sys_flock_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 7;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_flock_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_flock_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_fsync_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            
        };
        
        int syscall__trace_entry_fsync(struct pt_regs *ctx 
                        , int fd
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_fsync(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_fsync_event_t stats_key_v = {};
            struct sys_fsync_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 8;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_fsync_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_fsync_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_ftruncate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            
        };
        
        int syscall__trace_entry_ftruncate(struct pt_regs *ctx 
                        , int fd, int length
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_ftruncate(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_ftruncate_event_t stats_key_v = {};
            struct sys_ftruncate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 9;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_ftruncate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_ftruncate_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_lseek_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            
        };
        
        int syscall__trace_entry_lseek(struct pt_regs *ctx 
                        , int fd, int offset, int whence
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_lseek(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_lseek_event_t stats_key_v = {};
            struct sys_lseek_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 10;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_lseek_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_lseek_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_pread64_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_pread64(struct pt_regs *ctx 
                        , int fd, void *buf, u64 count, u64 pos
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_pread64(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_pread64_event_t stats_key_v = {};
            struct sys_pread64_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 11;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_pread64_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_pread64_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_preadv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_preadv(struct pt_regs *ctx 
                        , int fd, u64 buf, u64 vlen, u64 pos_l, u64 pos_h
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_preadv(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_preadv_event_t stats_key_v = {};
            struct sys_preadv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 12;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_preadv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_preadv_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_preadv2_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_preadv2(struct pt_regs *ctx 
                        , int fd, u64 buf, u64 vlen, u64 pos_l, u64 pos_h, u64 flags
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_preadv2(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_preadv2_event_t stats_key_v = {};
            struct sys_preadv2_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 13;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_preadv2_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_preadv2_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_pwrite64_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_pwrite64(struct pt_regs *ctx 
                        , int fd, const void *data, u64 count, u64 pos
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_pwrite64(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_pwrite64_event_t stats_key_v = {};
            struct sys_pwrite64_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 14;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_pwrite64_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_pwrite64_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_pwritev_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_pwritev(struct pt_regs *ctx 
                        , int fd, u64 buf, u64 vlen, u64 pos_l, u64 pos_h
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_pwritev(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_pwritev_event_t stats_key_v = {};
            struct sys_pwritev_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 15;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_pwritev_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_pwritev_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_pwritev2_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_pwritev2(struct pt_regs *ctx 
                        , int fd, u64 buf, u64 vlen, u64 pos_l, u64 pos_h, u64 flags
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_pwritev2(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_pwritev2_event_t stats_key_v = {};
            struct sys_pwritev2_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 16;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_pwritev2_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_pwritev2_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_readahead_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_readahead(struct pt_regs *ctx 
                        , int fd, u64 offset, u64 count
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_readahead(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_readahead_event_t stats_key_v = {};
            struct sys_readahead_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 17;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_readahead_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_readahead_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_readv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_readv(struct pt_regs *ctx 
                        , int fd, u64 vec, u64 vlen
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_readv(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_readv_event_t stats_key_v = {};
            struct sys_readv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 18;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_readv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_readv_event_t), 0);
        
            
        
            return 0;
        }
        
        
            struct sys_writev_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            u64 file_hash;
            u64 size_sum;
        };
        
        int syscall__trace_entry_writev(struct pt_regs *ctx 
                        , int fd, u64 vec, u64 vlen
                        ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
        
            
                        latest_fd.update(&id,&fd);
                           
            return 0;
        }

        int sys__trace_exit_writev(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
        
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct sys_writev_event_t stats_key_v = {};
            struct sys_writev_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 19;
            stats_key->ip = fn->ip;
        
            
                        int* fd_ptr = latest_fd.lookup(&id);
                        if (fd_ptr != 0 ) {
                            struct file_t file_key = {};
                            file_key.id = id;
                            file_key.fd = *fd_ptr;
                            u64* hash_ptr = fd_hash.lookup(&file_key);
                            if (hash_ptr != 0) {
                                stats_key->file_hash = *hash_ptr; 
                            }
                        }
                        
                        
            struct sys_writev_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
        
            
                                 stats->size_sum += PT_REGS_RC(ctx);
                                 
            // bpf_trace_printk("Submitting CUSTOM SYS IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct sys_writev_event_t), 0);
        
            
        
            return 0;
        }
        
        
        
            struct app_AllocResults_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_AllocResults_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_AllocResults_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_AllocResults_event_t stats_key_v = {};
            struct app_AllocResults_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 20;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_AllocResults_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_AllocResults_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_CreateTest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_CreateTest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_CreateTest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_CreateTest_event_t stats_key_v = {};
            struct app_CreateTest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 21;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_CreateTest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_CreateTest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_CurrentTimeString_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_CurrentTimeString_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_CurrentTimeString_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_CurrentTimeString_event_t stats_key_v = {};
            struct app_CurrentTimeString_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 22;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_CurrentTimeString_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_CurrentTimeString_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_DecodeDirective_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_DecodeDirective_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_DecodeDirective_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_DecodeDirective_event_t stats_key_v = {};
            struct app_DecodeDirective_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 23;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_DecodeDirective_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_DecodeDirective_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_DelaySecs_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_DelaySecs_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_DelaySecs_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_DelaySecs_event_t stats_key_v = {};
            struct app_DelaySecs_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 24;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_DelaySecs_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_DelaySecs_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_DumpBuffer_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_DumpBuffer_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_DumpBuffer_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_DumpBuffer_event_t stats_key_v = {};
            struct app_DumpBuffer_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 25;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_DumpBuffer_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_DumpBuffer_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ExtractHint_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ExtractHint_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ExtractHint_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ExtractHint_event_t stats_key_v = {};
            struct app_ExtractHint_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 26;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ExtractHint_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ExtractHint_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_FailMessage_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_FailMessage_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_FailMessage_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_FailMessage_event_t stats_key_v = {};
            struct app_FailMessage_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 27;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_FailMessage_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_FailMessage_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_FreeResults_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_FreeResults_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_FreeResults_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_FreeResults_event_t stats_key_v = {};
            struct app_FreeResults_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 28;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_FreeResults_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_FreeResults_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_GetNumNodes_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_GetNumNodes_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_GetNumNodes_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_GetNumNodes_event_t stats_key_v = {};
            struct app_GetNumNodes_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 29;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_GetNumNodes_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_GetNumNodes_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_GetNumTasks_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_GetNumTasks_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_GetNumTasks_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_GetNumTasks_event_t stats_key_v = {};
            struct app_GetNumTasks_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 30;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_GetNumTasks_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_GetNumTasks_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_GetNumTasksOnNode0_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_GetNumTasksOnNode0_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_GetNumTasksOnNode0_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_GetNumTasksOnNode0_event_t stats_key_v = {};
            struct app_GetNumTasksOnNode0_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 31;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_GetNumTasksOnNode0_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_GetNumTasksOnNode0_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_GetOffsetArrayRandom_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_GetOffsetArrayRandom_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_GetOffsetArrayRandom_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_GetOffsetArrayRandom_event_t stats_key_v = {};
            struct app_GetOffsetArrayRandom_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 32;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_GetOffsetArrayRandom_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_GetOffsetArrayRandom_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_GetPlatformName_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_GetPlatformName_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_GetPlatformName_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_GetPlatformName_event_t stats_key_v = {};
            struct app_GetPlatformName_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 33;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_GetPlatformName_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_GetPlatformName_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_GetProcessorAndCore_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_GetProcessorAndCore_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_GetProcessorAndCore_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_GetProcessorAndCore_event_t stats_key_v = {};
            struct app_GetProcessorAndCore_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 34;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_GetProcessorAndCore_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_GetProcessorAndCore_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_GetTestFileName_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_GetTestFileName_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_GetTestFileName_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_GetTestFileName_event_t stats_key_v = {};
            struct app_GetTestFileName_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 35;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_GetTestFileName_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_GetTestFileName_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_GetTimeStamp_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_GetTimeStamp_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_GetTimeStamp_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_GetTimeStamp_event_t stats_key_v = {};
            struct app_GetTimeStamp_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 36;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_GetTimeStamp_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_GetTimeStamp_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_HumanReadable_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_HumanReadable_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_HumanReadable_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_HumanReadable_event_t stats_key_v = {};
            struct app_HumanReadable_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 37;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_HumanReadable_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_HumanReadable_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_MPIIO_Access_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_MPIIO_Access_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_MPIIO_Access_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_MPIIO_Access_event_t stats_key_v = {};
            struct app_MPIIO_Access_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 38;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_MPIIO_Access_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_MPIIO_Access_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_MPIIO_Delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_MPIIO_Delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_MPIIO_Delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_MPIIO_Delete_event_t stats_key_v = {};
            struct app_MPIIO_Delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 39;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_MPIIO_Delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_MPIIO_Delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_MPIIO_GetFileSize_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_MPIIO_GetFileSize_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_MPIIO_GetFileSize_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_MPIIO_GetFileSize_event_t stats_key_v = {};
            struct app_MPIIO_GetFileSize_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 40;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_MPIIO_GetFileSize_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_MPIIO_GetFileSize_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_MPIIO_xfer_hints_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_MPIIO_xfer_hints_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_MPIIO_xfer_hints_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_MPIIO_xfer_hints_event_t stats_key_v = {};
            struct app_MPIIO_xfer_hints_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 41;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_MPIIO_xfer_hints_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_MPIIO_xfer_hints_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_NodeMemoryStringToBytes_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_NodeMemoryStringToBytes_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_NodeMemoryStringToBytes_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_NodeMemoryStringToBytes_event_t stats_key_v = {};
            struct app_NodeMemoryStringToBytes_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 42;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_NodeMemoryStringToBytes_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_NodeMemoryStringToBytes_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_OpTimerFlush_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_OpTimerFlush_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_OpTimerFlush_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_OpTimerFlush_event_t stats_key_v = {};
            struct app_OpTimerFlush_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 43;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_OpTimerFlush_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_OpTimerFlush_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_OpTimerFree_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_OpTimerFree_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_OpTimerFree_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_OpTimerFree_event_t stats_key_v = {};
            struct app_OpTimerFree_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 44;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_OpTimerFree_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_OpTimerFree_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_OpTimerInit_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_OpTimerInit_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_OpTimerInit_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_OpTimerInit_event_t stats_key_v = {};
            struct app_OpTimerInit_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 45;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_OpTimerInit_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_OpTimerInit_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_OpTimerValue_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_OpTimerValue_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_OpTimerValue_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_OpTimerValue_event_t stats_key_v = {};
            struct app_OpTimerValue_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 46;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_OpTimerValue_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_OpTimerValue_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_Close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_Close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_Close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_Close_event_t stats_key_v = {};
            struct app_POSIX_Close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 47;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_Close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_Close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_Create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_Create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_Create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_Create_event_t stats_key_v = {};
            struct app_POSIX_Create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 48;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_Create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_Create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_Delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_Delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_Delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_Delete_event_t stats_key_v = {};
            struct app_POSIX_Delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 49;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_Delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_Delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_Fsync_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_Fsync_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_Fsync_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_Fsync_event_t stats_key_v = {};
            struct app_POSIX_Fsync_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 50;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_Fsync_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_Fsync_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_GetFileSize_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_GetFileSize_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_GetFileSize_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_GetFileSize_event_t stats_key_v = {};
            struct app_POSIX_GetFileSize_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 51;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_GetFileSize_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_GetFileSize_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_Mknod_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_Mknod_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_Mknod_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_Mknod_event_t stats_key_v = {};
            struct app_POSIX_Mknod_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 52;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_Mknod_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_Mknod_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_Open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_Open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_Open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_Open_event_t stats_key_v = {};
            struct app_POSIX_Open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 53;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_Open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_Open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_Rename_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_Rename_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_Rename_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_Rename_event_t stats_key_v = {};
            struct app_POSIX_Rename_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 54;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_Rename_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_Rename_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_Sync_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_Sync_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_Sync_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_Sync_event_t stats_key_v = {};
            struct app_POSIX_Sync_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 55;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_Sync_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_Sync_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_check_params_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_check_params_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_check_params_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_check_params_event_t stats_key_v = {};
            struct app_POSIX_check_params_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 56;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_check_params_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_check_params_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_options_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_options_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_options_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_options_event_t stats_key_v = {};
            struct app_POSIX_options_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 57;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_options_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_options_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_POSIX_xfer_hints_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_POSIX_xfer_hints_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_POSIX_xfer_hints_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_POSIX_xfer_hints_event_t stats_key_v = {};
            struct app_POSIX_xfer_hints_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 58;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_POSIX_xfer_hints_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_POSIX_xfer_hints_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ParseCommandLine_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ParseCommandLine_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ParseCommandLine_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ParseCommandLine_event_t stats_key_v = {};
            struct app_ParseCommandLine_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 59;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ParseCommandLine_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ParseCommandLine_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ParseLine_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ParseLine_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ParseLine_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ParseLine_event_t stats_key_v = {};
            struct app_ParseLine_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 60;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ParseLine_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ParseLine_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintHeader_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintHeader_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintHeader_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintHeader_event_t stats_key_v = {};
            struct app_PrintHeader_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 61;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintHeader_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintHeader_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintKeyVal_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintKeyVal_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintKeyVal_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintKeyVal_event_t stats_key_v = {};
            struct app_PrintKeyVal_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 62;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintKeyVal_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintKeyVal_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintLongSummaryAllTests_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintLongSummaryAllTests_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintLongSummaryAllTests_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintLongSummaryAllTests_event_t stats_key_v = {};
            struct app_PrintLongSummaryAllTests_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 63;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintLongSummaryAllTests_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintLongSummaryAllTests_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintLongSummaryHeader_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintLongSummaryHeader_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintLongSummaryHeader_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintLongSummaryHeader_event_t stats_key_v = {};
            struct app_PrintLongSummaryHeader_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 64;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintLongSummaryHeader_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintLongSummaryHeader_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintLongSummaryOneTest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintLongSummaryOneTest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintLongSummaryOneTest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintLongSummaryOneTest_event_t stats_key_v = {};
            struct app_PrintLongSummaryOneTest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 65;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintLongSummaryOneTest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintLongSummaryOneTest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintReducedResult_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintReducedResult_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintReducedResult_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintReducedResult_event_t stats_key_v = {};
            struct app_PrintReducedResult_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 66;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintReducedResult_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintReducedResult_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintRemoveTiming_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintRemoveTiming_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintRemoveTiming_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintRemoveTiming_event_t stats_key_v = {};
            struct app_PrintRemoveTiming_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 67;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintRemoveTiming_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintRemoveTiming_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintRepeatEnd_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintRepeatEnd_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintRepeatEnd_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintRepeatEnd_event_t stats_key_v = {};
            struct app_PrintRepeatEnd_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 68;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintRepeatEnd_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintRepeatEnd_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintRepeatStart_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintRepeatStart_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintRepeatStart_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintRepeatStart_event_t stats_key_v = {};
            struct app_PrintRepeatStart_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 69;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintRepeatStart_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintRepeatStart_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintShortSummary_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintShortSummary_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintShortSummary_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintShortSummary_event_t stats_key_v = {};
            struct app_PrintShortSummary_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 70;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintShortSummary_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintShortSummary_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintTableHeader_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintTableHeader_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintTableHeader_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintTableHeader_event_t stats_key_v = {};
            struct app_PrintTableHeader_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 71;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintTableHeader_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintTableHeader_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintTestEnds_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintTestEnds_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintTestEnds_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintTestEnds_event_t stats_key_v = {};
            struct app_PrintTestEnds_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 72;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintTestEnds_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintTestEnds_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_PrintTimestamp_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_PrintTimestamp_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_PrintTimestamp_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_PrintTimestamp_event_t stats_key_v = {};
            struct app_PrintTimestamp_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 73;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_PrintTimestamp_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_PrintTimestamp_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_QueryNodeMapping_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_QueryNodeMapping_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_QueryNodeMapping_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_QueryNodeMapping_event_t stats_key_v = {};
            struct app_QueryNodeMapping_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 74;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_QueryNodeMapping_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_QueryNodeMapping_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ReadConfigScript_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ReadConfigScript_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ReadConfigScript_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ReadConfigScript_event_t stats_key_v = {};
            struct app_ReadConfigScript_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 75;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ReadConfigScript_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ReadConfigScript_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ReadStoneWallingIterations_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ReadStoneWallingIterations_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ReadStoneWallingIterations_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ReadStoneWallingIterations_event_t stats_key_v = {};
            struct app_ReadStoneWallingIterations_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 76;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ReadStoneWallingIterations_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ReadStoneWallingIterations_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_Regex_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_Regex_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_Regex_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_Regex_event_t stats_key_v = {};
            struct app_Regex_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 77;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_Regex_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_Regex_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_SetHints_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_SetHints_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_SetHints_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_SetHints_event_t stats_key_v = {};
            struct app_SetHints_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 78;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_SetHints_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_SetHints_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ShowFileSystemSize_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ShowFileSystemSize_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ShowFileSystemSize_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ShowFileSystemSize_event_t stats_key_v = {};
            struct app_ShowFileSystemSize_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 79;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ShowFileSystemSize_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ShowFileSystemSize_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ShowHints_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ShowHints_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ShowHints_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ShowHints_event_t stats_key_v = {};
            struct app_ShowHints_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 80;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ShowHints_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ShowHints_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ShowSetup_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ShowSetup_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ShowSetup_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ShowSetup_event_t stats_key_v = {};
            struct app_ShowSetup_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 81;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ShowSetup_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ShowSetup_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ShowTestEnd_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ShowTestEnd_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ShowTestEnd_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ShowTestEnd_event_t stats_key_v = {};
            struct app_ShowTestEnd_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 82;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ShowTestEnd_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ShowTestEnd_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ShowTestStart_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ShowTestStart_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ShowTestStart_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ShowTestStart_event_t stats_key_v = {};
            struct app_ShowTestStart_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 83;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ShowTestStart_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ShowTestStart_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_StoreStoneWallingIterations_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_StoreStoneWallingIterations_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_StoreStoneWallingIterations_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_StoreStoneWallingIterations_event_t stats_key_v = {};
            struct app_StoreStoneWallingIterations_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 84;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_StoreStoneWallingIterations_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_StoreStoneWallingIterations_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_StringToBytes_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_StringToBytes_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_StringToBytes_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_StringToBytes_event_t stats_key_v = {};
            struct app_StringToBytes_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 85;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_StringToBytes_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_StringToBytes_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app__fini_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app__fini_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app__fini_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app__fini_event_t stats_key_v = {};
            struct app__fini_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 86;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app__fini_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app__fini_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app__init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app__init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app__init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app__init_event_t stats_key_v = {};
            struct app__init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 87;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app__init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app__init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app__start_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app__start_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app__start_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app__start_event_t stats_key_v = {};
            struct app__start_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 88;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app__start_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app__start_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_count_event_t stats_key_v = {};
            struct app_aiori_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 89;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_default_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_default_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_default_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_default_event_t stats_key_v = {};
            struct app_aiori_default_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 90;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_default_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_default_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_get_version_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_get_version_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_get_version_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_get_version_event_t stats_key_v = {};
            struct app_aiori_get_version_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 91;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_get_version_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_get_version_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_posix_access_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_posix_access_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_posix_access_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_posix_access_event_t stats_key_v = {};
            struct app_aiori_posix_access_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 92;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_posix_access_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_posix_access_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_posix_mkdir_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_posix_mkdir_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_posix_mkdir_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_posix_mkdir_event_t stats_key_v = {};
            struct app_aiori_posix_mkdir_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 93;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_posix_mkdir_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_posix_mkdir_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_posix_rmdir_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_posix_rmdir_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_posix_rmdir_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_posix_rmdir_event_t stats_key_v = {};
            struct app_aiori_posix_rmdir_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 94;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_posix_rmdir_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_posix_rmdir_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_posix_stat_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_posix_stat_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_posix_stat_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_posix_stat_event_t stats_key_v = {};
            struct app_aiori_posix_stat_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 95;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_posix_stat_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_posix_stat_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_posix_statfs_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_posix_statfs_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_posix_statfs_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_posix_statfs_event_t stats_key_v = {};
            struct app_aiori_posix_statfs_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 96;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_posix_statfs_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_posix_statfs_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_select_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_select_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_select_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_select_event_t stats_key_v = {};
            struct app_aiori_select_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 97;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_select_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_select_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aiori_supported_apis_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aiori_supported_apis_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aiori_supported_apis_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aiori_supported_apis_event_t stats_key_v = {};
            struct app_aiori_supported_apis_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 98;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aiori_supported_apis_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aiori_supported_apis_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_airoi_create_all_module_options_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_airoi_create_all_module_options_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_airoi_create_all_module_options_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_airoi_create_all_module_options_event_t stats_key_v = {};
            struct app_airoi_create_all_module_options_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 99;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_airoi_create_all_module_options_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_airoi_create_all_module_options_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_airoi_update_module_options_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_airoi_update_module_options_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_airoi_update_module_options_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_airoi_update_module_options_event_t stats_key_v = {};
            struct app_airoi_update_module_options_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 100;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_airoi_update_module_options_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_airoi_update_module_options_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aligned_buffer_alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aligned_buffer_alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aligned_buffer_alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aligned_buffer_alloc_event_t stats_key_v = {};
            struct app_aligned_buffer_alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 101;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aligned_buffer_alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aligned_buffer_alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_aligned_buffer_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_aligned_buffer_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_aligned_buffer_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_aligned_buffer_free_event_t stats_key_v = {};
            struct app_aligned_buffer_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 102;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_aligned_buffer_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_aligned_buffer_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_contains_only_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_contains_only_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_contains_only_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_contains_only_event_t stats_key_v = {};
            struct app_contains_only_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 103;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_contains_only_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_contains_only_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_createGlobalOptions_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_createGlobalOptions_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_createGlobalOptions_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_createGlobalOptions_event_t stats_key_v = {};
            struct app_createGlobalOptions_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 104;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_createGlobalOptions_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_createGlobalOptions_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_generate_memory_pattern_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_generate_memory_pattern_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_generate_memory_pattern_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_generate_memory_pattern_event_t stats_key_v = {};
            struct app_generate_memory_pattern_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 105;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_generate_memory_pattern_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_generate_memory_pattern_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_initCUDA_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_initCUDA_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_initCUDA_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_initCUDA_event_t stats_key_v = {};
            struct app_initCUDA_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 106;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_initCUDA_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_initCUDA_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_init_IOR_Param_t_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_init_IOR_Param_t_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_init_IOR_Param_t_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_init_IOR_Param_t_event_t stats_key_v = {};
            struct app_init_IOR_Param_t_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 107;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_init_IOR_Param_t_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_init_IOR_Param_t_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_init_clock_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_init_clock_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_init_clock_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_init_clock_event_t stats_key_v = {};
            struct app_init_clock_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 108;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_init_clock_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_init_clock_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_invalidate_buffer_pattern_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_invalidate_buffer_pattern_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_invalidate_buffer_pattern_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_invalidate_buffer_pattern_event_t stats_key_v = {};
            struct app_invalidate_buffer_pattern_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 109;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_invalidate_buffer_pattern_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_invalidate_buffer_pattern_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ior_main_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ior_main_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ior_main_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ior_main_event_t stats_key_v = {};
            struct app_ior_main_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 110;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ior_main_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ior_main_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_ior_run_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_ior_run_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_ior_run_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_ior_run_event_t stats_key_v = {};
            struct app_ior_run_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 111;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_ior_run_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_ior_run_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_main_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_main_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_main_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_main_event_t stats_key_v = {};
            struct app_main_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 112;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_main_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_main_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_option_merge_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_option_merge_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_option_merge_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_option_merge_event_t stats_key_v = {};
            struct app_option_merge_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 113;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_option_merge_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_option_merge_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_option_parse_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_option_parse_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_option_parse_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_option_parse_event_t stats_key_v = {};
            struct app_option_parse_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 114;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_option_parse_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_option_parse_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_option_parse_key_value_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_option_parse_key_value_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_option_parse_key_value_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_option_parse_key_value_event_t stats_key_v = {};
            struct app_option_parse_key_value_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 115;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_option_parse_key_value_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_option_parse_key_value_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_option_parse_str_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_option_parse_str_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_option_parse_str_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_option_parse_str_event_t stats_key_v = {};
            struct app_option_parse_str_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 116;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_option_parse_str_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_option_parse_str_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_option_print_current_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_option_print_current_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_option_print_current_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_option_print_current_event_t stats_key_v = {};
            struct app_option_print_current_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 117;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_option_print_current_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_option_print_current_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_option_print_help_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_option_print_help_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_option_print_help_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_option_print_help_event_t stats_key_v = {};
            struct app_option_print_help_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 118;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_option_print_help_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_option_print_help_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_parsePacketType_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_parsePacketType_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_parsePacketType_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_parsePacketType_event_t stats_key_v = {};
            struct app_parsePacketType_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 119;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_parsePacketType_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_parsePacketType_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_safeMalloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_safeMalloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_safeMalloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_safeMalloc_event_t stats_key_v = {};
            struct app_safeMalloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 120;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_safeMalloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_safeMalloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_set_o_direct_flag_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_set_o_direct_flag_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_set_o_direct_flag_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_set_o_direct_flag_event_t stats_key_v = {};
            struct app_set_o_direct_flag_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 121;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_set_o_direct_flag_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_set_o_direct_flag_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_string_to_bytes_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_string_to_bytes_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_string_to_bytes_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_string_to_bytes_event_t stats_key_v = {};
            struct app_string_to_bytes_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 122;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_string_to_bytes_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_string_to_bytes_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_test_time_elapsed_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_test_time_elapsed_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_test_time_elapsed_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_test_time_elapsed_event_t stats_key_v = {};
            struct app_test_time_elapsed_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 123;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_test_time_elapsed_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_test_time_elapsed_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_updateParsedOptions_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_updateParsedOptions_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_updateParsedOptions_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_updateParsedOptions_event_t stats_key_v = {};
            struct app_updateParsedOptions_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 124;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_updateParsedOptions_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_updateParsedOptions_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_update_write_memory_pattern_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_update_write_memory_pattern_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_update_write_memory_pattern_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_update_write_memory_pattern_event_t stats_key_v = {};
            struct app_update_write_memory_pattern_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 125;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_update_write_memory_pattern_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_update_write_memory_pattern_event_t), 0);
        
            return 0;
        }
        
        
        
            struct app_verify_memory_pattern_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_app_verify_memory_pattern_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_app_verify_memory_pattern_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct app_verify_memory_pattern_event_t stats_key_v = {};
            struct app_verify_memory_pattern_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 126;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct app_verify_memory_pattern_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct app_verify_memory_pattern_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_ack_failed_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_ack_failed_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_ack_failed_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_ack_failed_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_ack_failed_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 127;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_ack_failed_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_ack_failed_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_agree_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_agree_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_agree_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_agree_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_agree_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 128;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_agree_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_agree_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_failure_ack_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_failure_ack_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_failure_ack_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_failure_ack_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_failure_ack_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 129;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_failure_ack_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_failure_ack_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_failure_get_acked_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_failure_get_acked_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_failure_get_acked_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_failure_get_acked_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_failure_get_acked_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 130;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_failure_get_acked_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_failure_get_acked_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_get_failed_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_get_failed_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_get_failed_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_get_failed_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_get_failed_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 131;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_get_failed_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_get_failed_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_iagree_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_iagree_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_iagree_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_iagree_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_iagree_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 132;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_iagree_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_iagree_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_is_revoked_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_is_revoked_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_is_revoked_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_is_revoked_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_is_revoked_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 133;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_is_revoked_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_is_revoked_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_revoke_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_revoke_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_revoke_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_revoke_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_revoke_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 134;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_revoke_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_revoke_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPIX_Comm_shrink_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPIX_Comm_shrink_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPIX_Comm_shrink_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPIX_Comm_shrink_event_t stats_key_v = {};
            struct mpi_PMPIX_Comm_shrink_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 135;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPIX_Comm_shrink_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPIX_Comm_shrink_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Abort_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Abort_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Abort_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Abort_event_t stats_key_v = {};
            struct mpi_PMPI_Abort_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 136;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Abort_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Abort_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Accumulate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Accumulate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Accumulate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Accumulate_event_t stats_key_v = {};
            struct mpi_PMPI_Accumulate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 137;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Accumulate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Accumulate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Add_error_class_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Add_error_class_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Add_error_class_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Add_error_class_event_t stats_key_v = {};
            struct mpi_PMPI_Add_error_class_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 138;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Add_error_class_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Add_error_class_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Add_error_code_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Add_error_code_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Add_error_code_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Add_error_code_event_t stats_key_v = {};
            struct mpi_PMPI_Add_error_code_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 139;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Add_error_code_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Add_error_code_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Add_error_string_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Add_error_string_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Add_error_string_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Add_error_string_event_t stats_key_v = {};
            struct mpi_PMPI_Add_error_string_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 140;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Add_error_string_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Add_error_string_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Address_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Address_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Address_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Address_event_t stats_key_v = {};
            struct mpi_PMPI_Address_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 141;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Address_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Address_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Allgather_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Allgather_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Allgather_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Allgather_event_t stats_key_v = {};
            struct mpi_PMPI_Allgather_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 142;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Allgather_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Allgather_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Allgather_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Allgather_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Allgather_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Allgather_init_event_t stats_key_v = {};
            struct mpi_PMPI_Allgather_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 143;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Allgather_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Allgather_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Allgatherv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Allgatherv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Allgatherv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Allgatherv_event_t stats_key_v = {};
            struct mpi_PMPI_Allgatherv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 144;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Allgatherv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Allgatherv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Allgatherv_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Allgatherv_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Allgatherv_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Allgatherv_init_event_t stats_key_v = {};
            struct mpi_PMPI_Allgatherv_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 145;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Allgatherv_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Allgatherv_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Alloc_mem_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Alloc_mem_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Alloc_mem_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Alloc_mem_event_t stats_key_v = {};
            struct mpi_PMPI_Alloc_mem_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 146;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Alloc_mem_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Alloc_mem_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Allreduce_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Allreduce_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Allreduce_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Allreduce_event_t stats_key_v = {};
            struct mpi_PMPI_Allreduce_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 147;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Allreduce_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Allreduce_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Allreduce_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Allreduce_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Allreduce_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Allreduce_init_event_t stats_key_v = {};
            struct mpi_PMPI_Allreduce_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 148;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Allreduce_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Allreduce_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Alltoall_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Alltoall_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Alltoall_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Alltoall_event_t stats_key_v = {};
            struct mpi_PMPI_Alltoall_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 149;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Alltoall_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Alltoall_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Alltoall_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Alltoall_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Alltoall_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Alltoall_init_event_t stats_key_v = {};
            struct mpi_PMPI_Alltoall_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 150;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Alltoall_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Alltoall_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Alltoallv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Alltoallv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Alltoallv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Alltoallv_event_t stats_key_v = {};
            struct mpi_PMPI_Alltoallv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 151;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Alltoallv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Alltoallv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Alltoallv_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Alltoallv_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Alltoallv_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Alltoallv_init_event_t stats_key_v = {};
            struct mpi_PMPI_Alltoallv_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 152;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Alltoallv_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Alltoallv_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Alltoallw_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Alltoallw_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Alltoallw_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Alltoallw_event_t stats_key_v = {};
            struct mpi_PMPI_Alltoallw_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 153;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Alltoallw_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Alltoallw_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Alltoallw_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Alltoallw_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Alltoallw_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Alltoallw_init_event_t stats_key_v = {};
            struct mpi_PMPI_Alltoallw_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 154;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Alltoallw_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Alltoallw_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Attr_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Attr_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Attr_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Attr_delete_event_t stats_key_v = {};
            struct mpi_PMPI_Attr_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 155;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Attr_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Attr_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Attr_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Attr_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Attr_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Attr_get_event_t stats_key_v = {};
            struct mpi_PMPI_Attr_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 156;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Attr_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Attr_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Attr_put_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Attr_put_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Attr_put_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Attr_put_event_t stats_key_v = {};
            struct mpi_PMPI_Attr_put_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 157;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Attr_put_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Attr_put_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Barrier_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Barrier_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Barrier_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Barrier_event_t stats_key_v = {};
            struct mpi_PMPI_Barrier_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 158;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Barrier_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Barrier_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Barrier_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Barrier_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Barrier_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Barrier_init_event_t stats_key_v = {};
            struct mpi_PMPI_Barrier_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 159;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Barrier_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Barrier_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Bcast_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Bcast_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Bcast_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Bcast_event_t stats_key_v = {};
            struct mpi_PMPI_Bcast_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 160;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Bcast_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Bcast_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Bcast_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Bcast_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Bcast_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Bcast_init_event_t stats_key_v = {};
            struct mpi_PMPI_Bcast_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 161;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Bcast_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Bcast_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Bsend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Bsend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Bsend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Bsend_event_t stats_key_v = {};
            struct mpi_PMPI_Bsend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 162;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Bsend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Bsend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Bsend_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Bsend_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Bsend_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Bsend_init_event_t stats_key_v = {};
            struct mpi_PMPI_Bsend_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 163;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Bsend_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Bsend_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Buffer_attach_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Buffer_attach_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Buffer_attach_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Buffer_attach_event_t stats_key_v = {};
            struct mpi_PMPI_Buffer_attach_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 164;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Buffer_attach_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Buffer_attach_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Buffer_detach_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Buffer_detach_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Buffer_detach_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Buffer_detach_event_t stats_key_v = {};
            struct mpi_PMPI_Buffer_detach_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 165;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Buffer_detach_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Buffer_detach_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cancel_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cancel_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cancel_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cancel_event_t stats_key_v = {};
            struct mpi_PMPI_Cancel_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 166;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cancel_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cancel_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cart_coords_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cart_coords_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cart_coords_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cart_coords_event_t stats_key_v = {};
            struct mpi_PMPI_Cart_coords_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 167;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cart_coords_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cart_coords_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cart_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cart_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cart_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cart_create_event_t stats_key_v = {};
            struct mpi_PMPI_Cart_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 168;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cart_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cart_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cart_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cart_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cart_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cart_get_event_t stats_key_v = {};
            struct mpi_PMPI_Cart_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 169;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cart_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cart_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cart_map_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cart_map_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cart_map_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cart_map_event_t stats_key_v = {};
            struct mpi_PMPI_Cart_map_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 170;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cart_map_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cart_map_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cart_rank_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cart_rank_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cart_rank_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cart_rank_event_t stats_key_v = {};
            struct mpi_PMPI_Cart_rank_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 171;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cart_rank_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cart_rank_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cart_shift_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cart_shift_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cart_shift_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cart_shift_event_t stats_key_v = {};
            struct mpi_PMPI_Cart_shift_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 172;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cart_shift_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cart_shift_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cart_sub_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cart_sub_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cart_sub_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cart_sub_event_t stats_key_v = {};
            struct mpi_PMPI_Cart_sub_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 173;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cart_sub_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cart_sub_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Cartdim_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Cartdim_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Cartdim_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Cartdim_get_event_t stats_key_v = {};
            struct mpi_PMPI_Cartdim_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 174;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Cartdim_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Cartdim_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Close_port_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Close_port_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Close_port_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Close_port_event_t stats_key_v = {};
            struct mpi_PMPI_Close_port_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 175;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Close_port_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Close_port_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_accept_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_accept_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_accept_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_accept_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_accept_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 176;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_accept_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_accept_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 177;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_call_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_call_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_call_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_call_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_call_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 178;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_call_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_call_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_compare_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_compare_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_compare_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_compare_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_compare_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 179;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_compare_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_compare_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_connect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_connect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_connect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_connect_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_connect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 180;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_connect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_connect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_create_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 181;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_create_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_create_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_create_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_create_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_create_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 182;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_create_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_create_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_create_from_group_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_create_from_group_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_create_from_group_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_create_from_group_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_create_from_group_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 183;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_create_from_group_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_create_from_group_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_create_group_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_create_group_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_create_group_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_create_group_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_create_group_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 184;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_create_group_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_create_group_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_create_keyval_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_create_keyval_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_create_keyval_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_create_keyval_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_create_keyval_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 185;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_create_keyval_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_create_keyval_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_delete_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_delete_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_delete_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_delete_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_delete_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 186;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_delete_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_delete_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_disconnect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_disconnect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_disconnect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_disconnect_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_disconnect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 187;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_disconnect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_disconnect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_dup_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_dup_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_dup_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_dup_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_dup_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 188;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_dup_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_dup_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_dup_with_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_dup_with_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_dup_with_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_dup_with_info_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_dup_with_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 189;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_dup_with_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_dup_with_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 190;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_free_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 191;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_free_keyval_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_free_keyval_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_free_keyval_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_free_keyval_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_free_keyval_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 192;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_free_keyval_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_free_keyval_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_get_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_get_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_get_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_get_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_get_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 193;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_get_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_get_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_get_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_get_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_get_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_get_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_get_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 194;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_get_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_get_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_get_info_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 195;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_get_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_get_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_get_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_get_name_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_get_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 196;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_get_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_get_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_get_parent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_get_parent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_get_parent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_get_parent_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_get_parent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 197;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_get_parent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_get_parent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_group_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_group_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_group_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_group_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_group_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 198;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_group_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_group_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_idup_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_idup_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_idup_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_idup_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_idup_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 199;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_idup_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_idup_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_idup_with_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_idup_with_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_idup_with_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_idup_with_info_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_idup_with_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 200;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_idup_with_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_idup_with_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_join_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_join_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_join_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_join_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_join_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 201;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_join_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_join_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_rank_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_rank_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_rank_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_rank_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_rank_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 202;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_rank_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_rank_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_remote_group_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_remote_group_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_remote_group_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_remote_group_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_remote_group_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 203;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_remote_group_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_remote_group_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_remote_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_remote_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_remote_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_remote_size_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_remote_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 204;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_remote_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_remote_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_set_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_set_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_set_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_set_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_set_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 205;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_set_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_set_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_set_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_set_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_set_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_set_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_set_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 206;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_set_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_set_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_set_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_set_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_set_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_set_info_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_set_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 207;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_set_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_set_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_set_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_set_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_set_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_set_name_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_set_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 208;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_set_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_set_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_size_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 209;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_spawn_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_spawn_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_spawn_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_spawn_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_spawn_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 210;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_spawn_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_spawn_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_spawn_multiple_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_spawn_multiple_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_spawn_multiple_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_spawn_multiple_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_spawn_multiple_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 211;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_spawn_multiple_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_spawn_multiple_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_split_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_split_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_split_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_split_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_split_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 212;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_split_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_split_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_split_type_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_split_type_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_split_type_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_split_type_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_split_type_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 213;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_split_type_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_split_type_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Comm_test_inter_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Comm_test_inter_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Comm_test_inter_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Comm_test_inter_event_t stats_key_v = {};
            struct mpi_PMPI_Comm_test_inter_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 214;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Comm_test_inter_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Comm_test_inter_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Compare_and_swap_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Compare_and_swap_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Compare_and_swap_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Compare_and_swap_event_t stats_key_v = {};
            struct mpi_PMPI_Compare_and_swap_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 215;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Compare_and_swap_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Compare_and_swap_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Dims_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Dims_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Dims_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Dims_create_event_t stats_key_v = {};
            struct mpi_PMPI_Dims_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 216;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Dims_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Dims_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Dist_graph_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Dist_graph_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Dist_graph_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Dist_graph_create_event_t stats_key_v = {};
            struct mpi_PMPI_Dist_graph_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 217;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Dist_graph_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Dist_graph_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Dist_graph_create_adjacent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Dist_graph_create_adjacent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Dist_graph_create_adjacent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Dist_graph_create_adjacent_event_t stats_key_v = {};
            struct mpi_PMPI_Dist_graph_create_adjacent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 218;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Dist_graph_create_adjacent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Dist_graph_create_adjacent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Dist_graph_neighbors_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Dist_graph_neighbors_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Dist_graph_neighbors_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Dist_graph_neighbors_event_t stats_key_v = {};
            struct mpi_PMPI_Dist_graph_neighbors_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 219;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Dist_graph_neighbors_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Dist_graph_neighbors_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Dist_graph_neighbors_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Dist_graph_neighbors_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Dist_graph_neighbors_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Dist_graph_neighbors_count_event_t stats_key_v = {};
            struct mpi_PMPI_Dist_graph_neighbors_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 220;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Dist_graph_neighbors_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Dist_graph_neighbors_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Errhandler_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Errhandler_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Errhandler_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Errhandler_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Errhandler_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 221;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Errhandler_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Errhandler_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Errhandler_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Errhandler_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Errhandler_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Errhandler_create_event_t stats_key_v = {};
            struct mpi_PMPI_Errhandler_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 222;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Errhandler_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Errhandler_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Errhandler_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Errhandler_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Errhandler_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Errhandler_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Errhandler_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 223;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Errhandler_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Errhandler_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Errhandler_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Errhandler_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Errhandler_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Errhandler_free_event_t stats_key_v = {};
            struct mpi_PMPI_Errhandler_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 224;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Errhandler_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Errhandler_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Errhandler_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Errhandler_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Errhandler_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Errhandler_get_event_t stats_key_v = {};
            struct mpi_PMPI_Errhandler_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 225;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Errhandler_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Errhandler_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Errhandler_set_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Errhandler_set_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Errhandler_set_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Errhandler_set_event_t stats_key_v = {};
            struct mpi_PMPI_Errhandler_set_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 226;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Errhandler_set_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Errhandler_set_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Error_class_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Error_class_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Error_class_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Error_class_event_t stats_key_v = {};
            struct mpi_PMPI_Error_class_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 227;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Error_class_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Error_class_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Error_string_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Error_string_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Error_string_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Error_string_event_t stats_key_v = {};
            struct mpi_PMPI_Error_string_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 228;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Error_string_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Error_string_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Exscan_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Exscan_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Exscan_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Exscan_event_t stats_key_v = {};
            struct mpi_PMPI_Exscan_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 229;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Exscan_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Exscan_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Exscan_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Exscan_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Exscan_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Exscan_init_event_t stats_key_v = {};
            struct mpi_PMPI_Exscan_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 230;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Exscan_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Exscan_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Fetch_and_op_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Fetch_and_op_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Fetch_and_op_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Fetch_and_op_event_t stats_key_v = {};
            struct mpi_PMPI_Fetch_and_op_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 231;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Fetch_and_op_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Fetch_and_op_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_File_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 232;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_call_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_call_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_call_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_call_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_File_call_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 233;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_call_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_call_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_close_event_t stats_key_v = {};
            struct mpi_PMPI_File_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 234;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_create_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_create_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_create_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_create_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_File_create_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 235;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_create_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_create_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_delete_event_t stats_key_v = {};
            struct mpi_PMPI_File_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 236;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_File_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 237;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_amode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_amode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_amode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_amode_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_amode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 238;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_amode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_amode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_atomicity_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_atomicity_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_atomicity_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_atomicity_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_atomicity_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 239;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_atomicity_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_atomicity_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_byte_offset_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_byte_offset_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_byte_offset_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_byte_offset_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_byte_offset_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 240;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_byte_offset_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_byte_offset_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 241;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_group_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_group_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_group_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_group_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_group_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 242;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_group_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_group_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_info_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 243;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_position_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_position_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_position_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_position_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_position_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 244;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_position_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_position_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_position_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_position_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_position_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_position_shared_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_position_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 245;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_position_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_position_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_size_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 246;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_type_extent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_type_extent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_type_extent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_type_extent_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_type_extent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 247;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_type_extent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_type_extent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_get_view_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_get_view_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_get_view_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_get_view_event_t stats_key_v = {};
            struct mpi_PMPI_File_get_view_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 248;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_get_view_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_get_view_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iread_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iread_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iread_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iread_event_t stats_key_v = {};
            struct mpi_PMPI_File_iread_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 249;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iread_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iread_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iread_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iread_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iread_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iread_all_event_t stats_key_v = {};
            struct mpi_PMPI_File_iread_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 250;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iread_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iread_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iread_at_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iread_at_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iread_at_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iread_at_event_t stats_key_v = {};
            struct mpi_PMPI_File_iread_at_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 251;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iread_at_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iread_at_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iread_at_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iread_at_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iread_at_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iread_at_all_event_t stats_key_v = {};
            struct mpi_PMPI_File_iread_at_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 252;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iread_at_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iread_at_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iread_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iread_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iread_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iread_shared_event_t stats_key_v = {};
            struct mpi_PMPI_File_iread_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 253;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iread_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iread_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iwrite_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iwrite_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iwrite_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iwrite_event_t stats_key_v = {};
            struct mpi_PMPI_File_iwrite_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 254;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iwrite_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iwrite_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iwrite_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iwrite_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iwrite_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iwrite_all_event_t stats_key_v = {};
            struct mpi_PMPI_File_iwrite_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 255;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iwrite_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iwrite_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iwrite_at_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iwrite_at_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iwrite_at_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iwrite_at_event_t stats_key_v = {};
            struct mpi_PMPI_File_iwrite_at_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 256;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iwrite_at_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iwrite_at_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iwrite_at_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iwrite_at_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iwrite_at_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iwrite_at_all_event_t stats_key_v = {};
            struct mpi_PMPI_File_iwrite_at_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 257;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iwrite_at_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iwrite_at_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_iwrite_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_iwrite_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_iwrite_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_iwrite_shared_event_t stats_key_v = {};
            struct mpi_PMPI_File_iwrite_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 258;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_iwrite_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_iwrite_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_open_event_t stats_key_v = {};
            struct mpi_PMPI_File_open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 259;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_preallocate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_preallocate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_preallocate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_preallocate_event_t stats_key_v = {};
            struct mpi_PMPI_File_preallocate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 260;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_preallocate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_preallocate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 261;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_all_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 262;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_all_begin_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_all_begin_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_all_begin_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_all_begin_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_all_begin_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 263;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_all_begin_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_all_begin_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_all_end_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_all_end_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_all_end_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_all_end_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_all_end_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 264;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_all_end_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_all_end_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_at_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_at_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_at_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_at_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_at_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 265;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_at_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_at_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_at_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_at_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_at_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_at_all_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_at_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 266;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_at_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_at_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_at_all_begin_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_at_all_begin_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_at_all_begin_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_at_all_begin_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_at_all_begin_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 267;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_at_all_begin_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_at_all_begin_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_at_all_end_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_at_all_end_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_at_all_end_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_at_all_end_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_at_all_end_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 268;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_at_all_end_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_at_all_end_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_ordered_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_ordered_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_ordered_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_ordered_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_ordered_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 269;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_ordered_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_ordered_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_ordered_begin_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_ordered_begin_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_ordered_begin_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_ordered_begin_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_ordered_begin_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 270;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_ordered_begin_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_ordered_begin_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_ordered_end_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_ordered_end_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_ordered_end_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_ordered_end_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_ordered_end_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 271;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_ordered_end_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_ordered_end_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_read_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_read_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_read_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_read_shared_event_t stats_key_v = {};
            struct mpi_PMPI_File_read_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 272;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_read_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_read_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_seek_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_seek_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_seek_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_seek_event_t stats_key_v = {};
            struct mpi_PMPI_File_seek_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 273;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_seek_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_seek_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_seek_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_seek_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_seek_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_seek_shared_event_t stats_key_v = {};
            struct mpi_PMPI_File_seek_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 274;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_seek_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_seek_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_set_atomicity_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_set_atomicity_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_set_atomicity_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_set_atomicity_event_t stats_key_v = {};
            struct mpi_PMPI_File_set_atomicity_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 275;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_set_atomicity_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_set_atomicity_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_set_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_set_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_set_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_set_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_File_set_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 276;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_set_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_set_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_set_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_set_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_set_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_set_info_event_t stats_key_v = {};
            struct mpi_PMPI_File_set_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 277;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_set_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_set_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_set_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_set_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_set_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_set_size_event_t stats_key_v = {};
            struct mpi_PMPI_File_set_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 278;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_set_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_set_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_set_view_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_set_view_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_set_view_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_set_view_event_t stats_key_v = {};
            struct mpi_PMPI_File_set_view_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 279;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_set_view_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_set_view_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_sync_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_sync_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_sync_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_sync_event_t stats_key_v = {};
            struct mpi_PMPI_File_sync_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 280;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_sync_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_sync_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 281;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_all_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 282;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_all_begin_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_all_begin_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_all_begin_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_all_begin_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_all_begin_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 283;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_all_begin_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_all_begin_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_all_end_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_all_end_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_all_end_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_all_end_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_all_end_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 284;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_all_end_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_all_end_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_at_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_at_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_at_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_at_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_at_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 285;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_at_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_at_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_at_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_at_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_at_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_at_all_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_at_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 286;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_at_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_at_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_at_all_begin_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_at_all_begin_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_at_all_begin_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_at_all_begin_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_at_all_begin_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 287;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_at_all_begin_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_at_all_begin_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_at_all_end_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_at_all_end_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_at_all_end_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_at_all_end_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_at_all_end_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 288;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_at_all_end_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_at_all_end_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_ordered_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_ordered_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_ordered_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_ordered_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_ordered_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 289;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_ordered_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_ordered_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_ordered_begin_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_ordered_begin_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_ordered_begin_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_ordered_begin_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_ordered_begin_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 290;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_ordered_begin_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_ordered_begin_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_ordered_end_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_ordered_end_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_ordered_end_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_ordered_end_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_ordered_end_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 291;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_ordered_end_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_ordered_end_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_File_write_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_File_write_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_File_write_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_File_write_shared_event_t stats_key_v = {};
            struct mpi_PMPI_File_write_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 292;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_File_write_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_File_write_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Finalize_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Finalize_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Finalize_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Finalize_event_t stats_key_v = {};
            struct mpi_PMPI_Finalize_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 293;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Finalize_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Finalize_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Finalized_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Finalized_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Finalized_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Finalized_event_t stats_key_v = {};
            struct mpi_PMPI_Finalized_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 294;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Finalized_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Finalized_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Free_mem_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Free_mem_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Free_mem_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Free_mem_event_t stats_key_v = {};
            struct mpi_PMPI_Free_mem_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 295;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Free_mem_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Free_mem_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Gather_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Gather_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Gather_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Gather_event_t stats_key_v = {};
            struct mpi_PMPI_Gather_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 296;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Gather_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Gather_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Gather_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Gather_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Gather_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Gather_init_event_t stats_key_v = {};
            struct mpi_PMPI_Gather_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 297;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Gather_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Gather_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Gatherv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Gatherv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Gatherv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Gatherv_event_t stats_key_v = {};
            struct mpi_PMPI_Gatherv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 298;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Gatherv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Gatherv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Gatherv_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Gatherv_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Gatherv_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Gatherv_init_event_t stats_key_v = {};
            struct mpi_PMPI_Gatherv_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 299;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Gatherv_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Gatherv_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_event_t stats_key_v = {};
            struct mpi_PMPI_Get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 300;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_accumulate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_accumulate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_accumulate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_accumulate_event_t stats_key_v = {};
            struct mpi_PMPI_Get_accumulate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 301;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_accumulate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_accumulate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_address_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_address_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_address_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_address_event_t stats_key_v = {};
            struct mpi_PMPI_Get_address_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 302;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_address_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_address_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_count_event_t stats_key_v = {};
            struct mpi_PMPI_Get_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 303;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_elements_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_elements_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_elements_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_elements_event_t stats_key_v = {};
            struct mpi_PMPI_Get_elements_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 304;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_elements_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_elements_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_elements_x_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_elements_x_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_elements_x_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_elements_x_event_t stats_key_v = {};
            struct mpi_PMPI_Get_elements_x_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 305;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_elements_x_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_elements_x_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_library_version_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_library_version_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_library_version_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_library_version_event_t stats_key_v = {};
            struct mpi_PMPI_Get_library_version_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 306;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_library_version_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_library_version_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_processor_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_processor_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_processor_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_processor_name_event_t stats_key_v = {};
            struct mpi_PMPI_Get_processor_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 307;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_processor_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_processor_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Get_version_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Get_version_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Get_version_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Get_version_event_t stats_key_v = {};
            struct mpi_PMPI_Get_version_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 308;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Get_version_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Get_version_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Graph_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Graph_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Graph_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Graph_create_event_t stats_key_v = {};
            struct mpi_PMPI_Graph_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 309;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Graph_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Graph_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Graph_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Graph_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Graph_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Graph_get_event_t stats_key_v = {};
            struct mpi_PMPI_Graph_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 310;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Graph_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Graph_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Graph_map_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Graph_map_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Graph_map_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Graph_map_event_t stats_key_v = {};
            struct mpi_PMPI_Graph_map_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 311;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Graph_map_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Graph_map_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Graph_neighbors_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Graph_neighbors_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Graph_neighbors_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Graph_neighbors_event_t stats_key_v = {};
            struct mpi_PMPI_Graph_neighbors_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 312;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Graph_neighbors_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Graph_neighbors_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Graph_neighbors_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Graph_neighbors_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Graph_neighbors_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Graph_neighbors_count_event_t stats_key_v = {};
            struct mpi_PMPI_Graph_neighbors_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 313;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Graph_neighbors_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Graph_neighbors_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Graphdims_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Graphdims_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Graphdims_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Graphdims_get_event_t stats_key_v = {};
            struct mpi_PMPI_Graphdims_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 314;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Graphdims_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Graphdims_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Grequest_complete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Grequest_complete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Grequest_complete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Grequest_complete_event_t stats_key_v = {};
            struct mpi_PMPI_Grequest_complete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 315;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Grequest_complete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Grequest_complete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Grequest_start_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Grequest_start_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Grequest_start_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Grequest_start_event_t stats_key_v = {};
            struct mpi_PMPI_Grequest_start_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 316;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Grequest_start_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Grequest_start_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Group_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 317;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_compare_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_compare_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_compare_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_compare_event_t stats_key_v = {};
            struct mpi_PMPI_Group_compare_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 318;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_compare_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_compare_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_difference_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_difference_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_difference_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_difference_event_t stats_key_v = {};
            struct mpi_PMPI_Group_difference_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 319;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_difference_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_difference_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_excl_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_excl_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_excl_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_excl_event_t stats_key_v = {};
            struct mpi_PMPI_Group_excl_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 320;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_excl_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_excl_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Group_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 321;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_free_event_t stats_key_v = {};
            struct mpi_PMPI_Group_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 322;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_from_session_pset_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_from_session_pset_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_from_session_pset_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_from_session_pset_event_t stats_key_v = {};
            struct mpi_PMPI_Group_from_session_pset_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 323;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_from_session_pset_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_from_session_pset_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_incl_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_incl_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_incl_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_incl_event_t stats_key_v = {};
            struct mpi_PMPI_Group_incl_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 324;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_incl_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_incl_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_intersection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_intersection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_intersection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_intersection_event_t stats_key_v = {};
            struct mpi_PMPI_Group_intersection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 325;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_intersection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_intersection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_range_excl_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_range_excl_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_range_excl_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_range_excl_event_t stats_key_v = {};
            struct mpi_PMPI_Group_range_excl_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 326;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_range_excl_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_range_excl_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_range_incl_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_range_incl_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_range_incl_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_range_incl_event_t stats_key_v = {};
            struct mpi_PMPI_Group_range_incl_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 327;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_range_incl_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_range_incl_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_rank_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_rank_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_rank_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_rank_event_t stats_key_v = {};
            struct mpi_PMPI_Group_rank_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 328;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_rank_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_rank_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_size_event_t stats_key_v = {};
            struct mpi_PMPI_Group_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 329;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_translate_ranks_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_translate_ranks_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_translate_ranks_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_translate_ranks_event_t stats_key_v = {};
            struct mpi_PMPI_Group_translate_ranks_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 330;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_translate_ranks_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_translate_ranks_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Group_union_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Group_union_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Group_union_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Group_union_event_t stats_key_v = {};
            struct mpi_PMPI_Group_union_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 331;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Group_union_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Group_union_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Iallgather_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Iallgather_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Iallgather_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Iallgather_event_t stats_key_v = {};
            struct mpi_PMPI_Iallgather_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 332;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Iallgather_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Iallgather_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Iallgatherv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Iallgatherv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Iallgatherv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Iallgatherv_event_t stats_key_v = {};
            struct mpi_PMPI_Iallgatherv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 333;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Iallgatherv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Iallgatherv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Iallreduce_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Iallreduce_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Iallreduce_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Iallreduce_event_t stats_key_v = {};
            struct mpi_PMPI_Iallreduce_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 334;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Iallreduce_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Iallreduce_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ialltoall_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ialltoall_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ialltoall_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ialltoall_event_t stats_key_v = {};
            struct mpi_PMPI_Ialltoall_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 335;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ialltoall_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ialltoall_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ialltoallv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ialltoallv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ialltoallv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ialltoallv_event_t stats_key_v = {};
            struct mpi_PMPI_Ialltoallv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 336;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ialltoallv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ialltoallv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ialltoallw_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ialltoallw_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ialltoallw_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ialltoallw_event_t stats_key_v = {};
            struct mpi_PMPI_Ialltoallw_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 337;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ialltoallw_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ialltoallw_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ibarrier_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ibarrier_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ibarrier_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ibarrier_event_t stats_key_v = {};
            struct mpi_PMPI_Ibarrier_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 338;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ibarrier_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ibarrier_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ibcast_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ibcast_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ibcast_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ibcast_event_t stats_key_v = {};
            struct mpi_PMPI_Ibcast_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 339;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ibcast_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ibcast_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ibsend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ibsend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ibsend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ibsend_event_t stats_key_v = {};
            struct mpi_PMPI_Ibsend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 340;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ibsend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ibsend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Iexscan_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Iexscan_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Iexscan_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Iexscan_event_t stats_key_v = {};
            struct mpi_PMPI_Iexscan_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 341;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Iexscan_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Iexscan_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Igather_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Igather_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Igather_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Igather_event_t stats_key_v = {};
            struct mpi_PMPI_Igather_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 342;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Igather_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Igather_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Igatherv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Igatherv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Igatherv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Igatherv_event_t stats_key_v = {};
            struct mpi_PMPI_Igatherv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 343;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Igatherv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Igatherv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Improbe_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Improbe_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Improbe_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Improbe_event_t stats_key_v = {};
            struct mpi_PMPI_Improbe_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 344;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Improbe_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Improbe_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Imrecv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Imrecv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Imrecv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Imrecv_event_t stats_key_v = {};
            struct mpi_PMPI_Imrecv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 345;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Imrecv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Imrecv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ineighbor_allgather_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ineighbor_allgather_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ineighbor_allgather_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ineighbor_allgather_event_t stats_key_v = {};
            struct mpi_PMPI_Ineighbor_allgather_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 346;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ineighbor_allgather_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ineighbor_allgather_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ineighbor_allgatherv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ineighbor_allgatherv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ineighbor_allgatherv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ineighbor_allgatherv_event_t stats_key_v = {};
            struct mpi_PMPI_Ineighbor_allgatherv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 347;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ineighbor_allgatherv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ineighbor_allgatherv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ineighbor_alltoall_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ineighbor_alltoall_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ineighbor_alltoall_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ineighbor_alltoall_event_t stats_key_v = {};
            struct mpi_PMPI_Ineighbor_alltoall_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 348;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ineighbor_alltoall_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ineighbor_alltoall_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ineighbor_alltoallv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ineighbor_alltoallv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ineighbor_alltoallv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ineighbor_alltoallv_event_t stats_key_v = {};
            struct mpi_PMPI_Ineighbor_alltoallv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 349;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ineighbor_alltoallv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ineighbor_alltoallv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ineighbor_alltoallw_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ineighbor_alltoallw_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ineighbor_alltoallw_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ineighbor_alltoallw_event_t stats_key_v = {};
            struct mpi_PMPI_Ineighbor_alltoallw_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 350;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ineighbor_alltoallw_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ineighbor_alltoallw_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Info_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 351;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_create_event_t stats_key_v = {};
            struct mpi_PMPI_Info_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 352;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_create_env_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_create_env_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_create_env_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_create_env_event_t stats_key_v = {};
            struct mpi_PMPI_Info_create_env_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 353;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_create_env_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_create_env_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_delete_event_t stats_key_v = {};
            struct mpi_PMPI_Info_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 354;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_dup_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_dup_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_dup_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_dup_event_t stats_key_v = {};
            struct mpi_PMPI_Info_dup_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 355;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_dup_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_dup_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Info_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 356;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_free_event_t stats_key_v = {};
            struct mpi_PMPI_Info_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 357;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_get_event_t stats_key_v = {};
            struct mpi_PMPI_Info_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 358;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_get_nkeys_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_get_nkeys_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_get_nkeys_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_get_nkeys_event_t stats_key_v = {};
            struct mpi_PMPI_Info_get_nkeys_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 359;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_get_nkeys_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_get_nkeys_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_get_nthkey_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_get_nthkey_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_get_nthkey_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_get_nthkey_event_t stats_key_v = {};
            struct mpi_PMPI_Info_get_nthkey_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 360;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_get_nthkey_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_get_nthkey_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_get_string_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_get_string_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_get_string_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_get_string_event_t stats_key_v = {};
            struct mpi_PMPI_Info_get_string_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 361;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_get_string_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_get_string_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_get_valuelen_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_get_valuelen_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_get_valuelen_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_get_valuelen_event_t stats_key_v = {};
            struct mpi_PMPI_Info_get_valuelen_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 362;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_get_valuelen_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_get_valuelen_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Info_set_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Info_set_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Info_set_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Info_set_event_t stats_key_v = {};
            struct mpi_PMPI_Info_set_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 363;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Info_set_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Info_set_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Init_event_t stats_key_v = {};
            struct mpi_PMPI_Init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 364;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Init_thread_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Init_thread_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Init_thread_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Init_thread_event_t stats_key_v = {};
            struct mpi_PMPI_Init_thread_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 365;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Init_thread_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Init_thread_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Initialized_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Initialized_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Initialized_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Initialized_event_t stats_key_v = {};
            struct mpi_PMPI_Initialized_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 366;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Initialized_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Initialized_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Intercomm_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Intercomm_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Intercomm_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Intercomm_create_event_t stats_key_v = {};
            struct mpi_PMPI_Intercomm_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 367;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Intercomm_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Intercomm_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Intercomm_create_from_groups_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Intercomm_create_from_groups_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Intercomm_create_from_groups_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Intercomm_create_from_groups_event_t stats_key_v = {};
            struct mpi_PMPI_Intercomm_create_from_groups_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 368;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Intercomm_create_from_groups_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Intercomm_create_from_groups_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Intercomm_merge_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Intercomm_merge_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Intercomm_merge_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Intercomm_merge_event_t stats_key_v = {};
            struct mpi_PMPI_Intercomm_merge_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 369;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Intercomm_merge_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Intercomm_merge_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Iprobe_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Iprobe_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Iprobe_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Iprobe_event_t stats_key_v = {};
            struct mpi_PMPI_Iprobe_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 370;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Iprobe_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Iprobe_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Irecv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Irecv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Irecv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Irecv_event_t stats_key_v = {};
            struct mpi_PMPI_Irecv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 371;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Irecv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Irecv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ireduce_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ireduce_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ireduce_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ireduce_event_t stats_key_v = {};
            struct mpi_PMPI_Ireduce_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 372;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ireduce_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ireduce_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ireduce_scatter_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ireduce_scatter_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ireduce_scatter_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ireduce_scatter_event_t stats_key_v = {};
            struct mpi_PMPI_Ireduce_scatter_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 373;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ireduce_scatter_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ireduce_scatter_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ireduce_scatter_block_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ireduce_scatter_block_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ireduce_scatter_block_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ireduce_scatter_block_event_t stats_key_v = {};
            struct mpi_PMPI_Ireduce_scatter_block_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 374;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ireduce_scatter_block_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ireduce_scatter_block_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Irsend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Irsend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Irsend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Irsend_event_t stats_key_v = {};
            struct mpi_PMPI_Irsend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 375;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Irsend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Irsend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Is_thread_main_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Is_thread_main_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Is_thread_main_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Is_thread_main_event_t stats_key_v = {};
            struct mpi_PMPI_Is_thread_main_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 376;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Is_thread_main_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Is_thread_main_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Iscan_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Iscan_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Iscan_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Iscan_event_t stats_key_v = {};
            struct mpi_PMPI_Iscan_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 377;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Iscan_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Iscan_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Iscatter_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Iscatter_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Iscatter_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Iscatter_event_t stats_key_v = {};
            struct mpi_PMPI_Iscatter_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 378;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Iscatter_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Iscatter_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Iscatterv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Iscatterv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Iscatterv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Iscatterv_event_t stats_key_v = {};
            struct mpi_PMPI_Iscatterv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 379;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Iscatterv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Iscatterv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Isend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Isend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Isend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Isend_event_t stats_key_v = {};
            struct mpi_PMPI_Isend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 380;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Isend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Isend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Isendrecv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Isendrecv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Isendrecv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Isendrecv_event_t stats_key_v = {};
            struct mpi_PMPI_Isendrecv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 381;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Isendrecv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Isendrecv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Isendrecv_replace_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Isendrecv_replace_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Isendrecv_replace_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Isendrecv_replace_event_t stats_key_v = {};
            struct mpi_PMPI_Isendrecv_replace_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 382;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Isendrecv_replace_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Isendrecv_replace_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Issend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Issend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Issend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Issend_event_t stats_key_v = {};
            struct mpi_PMPI_Issend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 383;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Issend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Issend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Keyval_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Keyval_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Keyval_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Keyval_create_event_t stats_key_v = {};
            struct mpi_PMPI_Keyval_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 384;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Keyval_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Keyval_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Keyval_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Keyval_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Keyval_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Keyval_free_event_t stats_key_v = {};
            struct mpi_PMPI_Keyval_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 385;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Keyval_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Keyval_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Lookup_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Lookup_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Lookup_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Lookup_name_event_t stats_key_v = {};
            struct mpi_PMPI_Lookup_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 386;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Lookup_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Lookup_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Message_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Message_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Message_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Message_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Message_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 387;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Message_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Message_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Message_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Message_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Message_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Message_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Message_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 388;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Message_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Message_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Mprobe_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Mprobe_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Mprobe_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Mprobe_event_t stats_key_v = {};
            struct mpi_PMPI_Mprobe_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 389;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Mprobe_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Mprobe_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Mrecv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Mrecv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Mrecv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Mrecv_event_t stats_key_v = {};
            struct mpi_PMPI_Mrecv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 390;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Mrecv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Mrecv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_allgather_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_allgather_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_allgather_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_allgather_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_allgather_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 391;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_allgather_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_allgather_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_allgather_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_allgather_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_allgather_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_allgather_init_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_allgather_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 392;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_allgather_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_allgather_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_allgatherv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_allgatherv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_allgatherv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_allgatherv_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_allgatherv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 393;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_allgatherv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_allgatherv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_allgatherv_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_allgatherv_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_allgatherv_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_allgatherv_init_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_allgatherv_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 394;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_allgatherv_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_allgatherv_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_alltoall_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_alltoall_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_alltoall_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_alltoall_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_alltoall_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 395;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_alltoall_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_alltoall_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_alltoall_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_alltoall_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_alltoall_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_alltoall_init_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_alltoall_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 396;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_alltoall_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_alltoall_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_alltoallv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_alltoallv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_alltoallv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_alltoallv_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_alltoallv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 397;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_alltoallv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_alltoallv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_alltoallv_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_alltoallv_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_alltoallv_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_alltoallv_init_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_alltoallv_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 398;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_alltoallv_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_alltoallv_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_alltoallw_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_alltoallw_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_alltoallw_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_alltoallw_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_alltoallw_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 399;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_alltoallw_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_alltoallw_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Neighbor_alltoallw_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Neighbor_alltoallw_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Neighbor_alltoallw_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Neighbor_alltoallw_init_event_t stats_key_v = {};
            struct mpi_PMPI_Neighbor_alltoallw_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 400;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Neighbor_alltoallw_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Neighbor_alltoallw_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Op_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Op_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Op_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Op_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Op_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 401;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Op_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Op_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Op_commutative_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Op_commutative_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Op_commutative_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Op_commutative_event_t stats_key_v = {};
            struct mpi_PMPI_Op_commutative_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 402;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Op_commutative_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Op_commutative_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Op_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Op_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Op_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Op_create_event_t stats_key_v = {};
            struct mpi_PMPI_Op_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 403;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Op_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Op_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Op_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Op_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Op_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Op_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Op_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 404;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Op_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Op_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Op_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Op_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Op_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Op_free_event_t stats_key_v = {};
            struct mpi_PMPI_Op_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 405;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Op_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Op_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Open_port_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Open_port_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Open_port_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Open_port_event_t stats_key_v = {};
            struct mpi_PMPI_Open_port_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 406;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Open_port_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Open_port_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Pack_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Pack_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Pack_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Pack_event_t stats_key_v = {};
            struct mpi_PMPI_Pack_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 407;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Pack_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Pack_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Pack_external_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Pack_external_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Pack_external_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Pack_external_event_t stats_key_v = {};
            struct mpi_PMPI_Pack_external_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 408;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Pack_external_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Pack_external_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Pack_external_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Pack_external_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Pack_external_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Pack_external_size_event_t stats_key_v = {};
            struct mpi_PMPI_Pack_external_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 409;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Pack_external_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Pack_external_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Pack_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Pack_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Pack_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Pack_size_event_t stats_key_v = {};
            struct mpi_PMPI_Pack_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 410;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Pack_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Pack_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Parrived_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Parrived_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Parrived_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Parrived_event_t stats_key_v = {};
            struct mpi_PMPI_Parrived_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 411;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Parrived_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Parrived_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Pcontrol_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Pcontrol_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Pcontrol_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Pcontrol_event_t stats_key_v = {};
            struct mpi_PMPI_Pcontrol_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 412;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Pcontrol_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Pcontrol_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Pready_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Pready_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Pready_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Pready_event_t stats_key_v = {};
            struct mpi_PMPI_Pready_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 413;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Pready_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Pready_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Pready_list_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Pready_list_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Pready_list_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Pready_list_event_t stats_key_v = {};
            struct mpi_PMPI_Pready_list_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 414;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Pready_list_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Pready_list_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Pready_range_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Pready_range_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Pready_range_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Pready_range_event_t stats_key_v = {};
            struct mpi_PMPI_Pready_range_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 415;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Pready_range_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Pready_range_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Precv_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Precv_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Precv_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Precv_init_event_t stats_key_v = {};
            struct mpi_PMPI_Precv_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 416;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Precv_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Precv_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Probe_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Probe_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Probe_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Probe_event_t stats_key_v = {};
            struct mpi_PMPI_Probe_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 417;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Probe_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Probe_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Psend_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Psend_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Psend_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Psend_init_event_t stats_key_v = {};
            struct mpi_PMPI_Psend_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 418;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Psend_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Psend_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Publish_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Publish_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Publish_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Publish_name_event_t stats_key_v = {};
            struct mpi_PMPI_Publish_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 419;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Publish_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Publish_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Put_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Put_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Put_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Put_event_t stats_key_v = {};
            struct mpi_PMPI_Put_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 420;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Put_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Put_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Query_thread_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Query_thread_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Query_thread_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Query_thread_event_t stats_key_v = {};
            struct mpi_PMPI_Query_thread_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 421;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Query_thread_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Query_thread_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Raccumulate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Raccumulate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Raccumulate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Raccumulate_event_t stats_key_v = {};
            struct mpi_PMPI_Raccumulate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 422;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Raccumulate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Raccumulate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Recv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Recv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Recv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Recv_event_t stats_key_v = {};
            struct mpi_PMPI_Recv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 423;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Recv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Recv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Recv_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Recv_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Recv_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Recv_init_event_t stats_key_v = {};
            struct mpi_PMPI_Recv_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 424;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Recv_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Recv_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Reduce_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Reduce_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Reduce_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Reduce_event_t stats_key_v = {};
            struct mpi_PMPI_Reduce_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 425;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Reduce_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Reduce_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Reduce_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Reduce_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Reduce_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Reduce_init_event_t stats_key_v = {};
            struct mpi_PMPI_Reduce_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 426;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Reduce_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Reduce_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Reduce_local_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Reduce_local_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Reduce_local_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Reduce_local_event_t stats_key_v = {};
            struct mpi_PMPI_Reduce_local_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 427;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Reduce_local_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Reduce_local_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Reduce_scatter_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Reduce_scatter_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Reduce_scatter_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Reduce_scatter_event_t stats_key_v = {};
            struct mpi_PMPI_Reduce_scatter_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 428;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Reduce_scatter_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Reduce_scatter_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Reduce_scatter_block_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Reduce_scatter_block_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Reduce_scatter_block_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Reduce_scatter_block_event_t stats_key_v = {};
            struct mpi_PMPI_Reduce_scatter_block_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 429;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Reduce_scatter_block_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Reduce_scatter_block_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Reduce_scatter_block_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Reduce_scatter_block_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Reduce_scatter_block_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Reduce_scatter_block_init_event_t stats_key_v = {};
            struct mpi_PMPI_Reduce_scatter_block_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 430;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Reduce_scatter_block_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Reduce_scatter_block_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Reduce_scatter_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Reduce_scatter_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Reduce_scatter_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Reduce_scatter_init_event_t stats_key_v = {};
            struct mpi_PMPI_Reduce_scatter_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 431;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Reduce_scatter_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Reduce_scatter_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Register_datarep_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Register_datarep_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Register_datarep_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Register_datarep_event_t stats_key_v = {};
            struct mpi_PMPI_Register_datarep_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 432;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Register_datarep_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Register_datarep_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Request_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Request_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Request_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Request_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Request_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 433;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Request_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Request_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Request_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Request_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Request_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Request_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Request_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 434;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Request_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Request_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Request_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Request_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Request_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Request_free_event_t stats_key_v = {};
            struct mpi_PMPI_Request_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 435;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Request_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Request_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Request_get_status_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Request_get_status_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Request_get_status_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Request_get_status_event_t stats_key_v = {};
            struct mpi_PMPI_Request_get_status_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 436;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Request_get_status_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Request_get_status_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Rget_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Rget_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Rget_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Rget_event_t stats_key_v = {};
            struct mpi_PMPI_Rget_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 437;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Rget_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Rget_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Rget_accumulate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Rget_accumulate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Rget_accumulate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Rget_accumulate_event_t stats_key_v = {};
            struct mpi_PMPI_Rget_accumulate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 438;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Rget_accumulate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Rget_accumulate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Rput_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Rput_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Rput_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Rput_event_t stats_key_v = {};
            struct mpi_PMPI_Rput_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 439;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Rput_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Rput_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Rsend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Rsend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Rsend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Rsend_event_t stats_key_v = {};
            struct mpi_PMPI_Rsend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 440;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Rsend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Rsend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Rsend_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Rsend_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Rsend_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Rsend_init_event_t stats_key_v = {};
            struct mpi_PMPI_Rsend_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 441;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Rsend_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Rsend_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Scan_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Scan_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Scan_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Scan_event_t stats_key_v = {};
            struct mpi_PMPI_Scan_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 442;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Scan_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Scan_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Scan_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Scan_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Scan_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Scan_init_event_t stats_key_v = {};
            struct mpi_PMPI_Scan_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 443;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Scan_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Scan_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Scatter_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Scatter_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Scatter_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Scatter_event_t stats_key_v = {};
            struct mpi_PMPI_Scatter_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 444;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Scatter_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Scatter_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Scatter_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Scatter_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Scatter_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Scatter_init_event_t stats_key_v = {};
            struct mpi_PMPI_Scatter_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 445;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Scatter_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Scatter_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Scatterv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Scatterv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Scatterv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Scatterv_event_t stats_key_v = {};
            struct mpi_PMPI_Scatterv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 446;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Scatterv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Scatterv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Scatterv_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Scatterv_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Scatterv_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Scatterv_init_event_t stats_key_v = {};
            struct mpi_PMPI_Scatterv_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 447;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Scatterv_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Scatterv_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Send_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Send_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Send_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Send_event_t stats_key_v = {};
            struct mpi_PMPI_Send_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 448;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Send_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Send_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Send_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Send_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Send_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Send_init_event_t stats_key_v = {};
            struct mpi_PMPI_Send_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 449;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Send_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Send_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Sendrecv_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Sendrecv_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Sendrecv_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Sendrecv_event_t stats_key_v = {};
            struct mpi_PMPI_Sendrecv_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 450;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Sendrecv_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Sendrecv_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Sendrecv_replace_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Sendrecv_replace_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Sendrecv_replace_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Sendrecv_replace_event_t stats_key_v = {};
            struct mpi_PMPI_Sendrecv_replace_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 451;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Sendrecv_replace_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Sendrecv_replace_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Session_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 452;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_call_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_call_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_call_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_call_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Session_call_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 453;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_call_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_call_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_create_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_create_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_create_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_create_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Session_create_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 454;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_create_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_create_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Session_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 455;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_finalize_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_finalize_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_finalize_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_finalize_event_t stats_key_v = {};
            struct mpi_PMPI_Session_finalize_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 456;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_finalize_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_finalize_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_get_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_get_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_get_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_get_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Session_get_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 457;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_get_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_get_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_get_info_event_t stats_key_v = {};
            struct mpi_PMPI_Session_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 458;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_get_nth_pset_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_get_nth_pset_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_get_nth_pset_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_get_nth_pset_event_t stats_key_v = {};
            struct mpi_PMPI_Session_get_nth_pset_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 459;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_get_nth_pset_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_get_nth_pset_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_get_num_psets_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_get_num_psets_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_get_num_psets_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_get_num_psets_event_t stats_key_v = {};
            struct mpi_PMPI_Session_get_num_psets_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 460;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_get_num_psets_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_get_num_psets_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_get_pset_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_get_pset_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_get_pset_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_get_pset_info_event_t stats_key_v = {};
            struct mpi_PMPI_Session_get_pset_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 461;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_get_pset_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_get_pset_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_init_event_t stats_key_v = {};
            struct mpi_PMPI_Session_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 462;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_set_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_set_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_set_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_set_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Session_set_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 463;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_set_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_set_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Session_set_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Session_set_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Session_set_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Session_set_info_event_t stats_key_v = {};
            struct mpi_PMPI_Session_set_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 464;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Session_set_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Session_set_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ssend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ssend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ssend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ssend_event_t stats_key_v = {};
            struct mpi_PMPI_Ssend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 465;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ssend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ssend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Ssend_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Ssend_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Ssend_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Ssend_init_event_t stats_key_v = {};
            struct mpi_PMPI_Ssend_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 466;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Ssend_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Ssend_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Start_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Start_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Start_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Start_event_t stats_key_v = {};
            struct mpi_PMPI_Start_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 467;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Start_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Start_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Startall_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Startall_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Startall_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Startall_event_t stats_key_v = {};
            struct mpi_PMPI_Startall_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 468;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Startall_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Startall_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Status_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 469;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_c2f08_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_c2f08_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_c2f08_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_c2f08_event_t stats_key_v = {};
            struct mpi_PMPI_Status_c2f08_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 470;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_c2f08_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_c2f08_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_f082c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_f082c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_f082c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_f082c_event_t stats_key_v = {};
            struct mpi_PMPI_Status_f082c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 471;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_f082c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_f082c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_f082f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_f082f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_f082f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_f082f_event_t stats_key_v = {};
            struct mpi_PMPI_Status_f082f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 472;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_f082f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_f082f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Status_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 473;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_f2f08_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_f2f08_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_f2f08_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_f2f08_event_t stats_key_v = {};
            struct mpi_PMPI_Status_f2f08_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 474;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_f2f08_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_f2f08_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_set_cancelled_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_set_cancelled_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_set_cancelled_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_set_cancelled_event_t stats_key_v = {};
            struct mpi_PMPI_Status_set_cancelled_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 475;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_set_cancelled_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_set_cancelled_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_set_elements_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_set_elements_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_set_elements_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_set_elements_event_t stats_key_v = {};
            struct mpi_PMPI_Status_set_elements_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 476;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_set_elements_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_set_elements_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Status_set_elements_x_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Status_set_elements_x_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Status_set_elements_x_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Status_set_elements_x_event_t stats_key_v = {};
            struct mpi_PMPI_Status_set_elements_x_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 477;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Status_set_elements_x_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Status_set_elements_x_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_category_changed_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_category_changed_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_category_changed_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_category_changed_event_t stats_key_v = {};
            struct mpi_PMPI_T_category_changed_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 478;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_category_changed_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_category_changed_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_category_get_categories_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_category_get_categories_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_category_get_categories_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_category_get_categories_event_t stats_key_v = {};
            struct mpi_PMPI_T_category_get_categories_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 479;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_category_get_categories_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_category_get_categories_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_category_get_cvars_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_category_get_cvars_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_category_get_cvars_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_category_get_cvars_event_t stats_key_v = {};
            struct mpi_PMPI_T_category_get_cvars_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 480;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_category_get_cvars_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_category_get_cvars_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_category_get_index_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_category_get_index_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_category_get_index_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_category_get_index_event_t stats_key_v = {};
            struct mpi_PMPI_T_category_get_index_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 481;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_category_get_index_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_category_get_index_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_category_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_category_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_category_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_category_get_info_event_t stats_key_v = {};
            struct mpi_PMPI_T_category_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 482;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_category_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_category_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_category_get_num_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_category_get_num_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_category_get_num_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_category_get_num_event_t stats_key_v = {};
            struct mpi_PMPI_T_category_get_num_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 483;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_category_get_num_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_category_get_num_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_category_get_pvars_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_category_get_pvars_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_category_get_pvars_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_category_get_pvars_event_t stats_key_v = {};
            struct mpi_PMPI_T_category_get_pvars_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 484;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_category_get_pvars_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_category_get_pvars_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_cvar_get_index_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_cvar_get_index_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_cvar_get_index_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_cvar_get_index_event_t stats_key_v = {};
            struct mpi_PMPI_T_cvar_get_index_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 485;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_cvar_get_index_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_cvar_get_index_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_cvar_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_cvar_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_cvar_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_cvar_get_info_event_t stats_key_v = {};
            struct mpi_PMPI_T_cvar_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 486;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_cvar_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_cvar_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_cvar_get_num_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_cvar_get_num_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_cvar_get_num_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_cvar_get_num_event_t stats_key_v = {};
            struct mpi_PMPI_T_cvar_get_num_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 487;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_cvar_get_num_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_cvar_get_num_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_cvar_handle_alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_cvar_handle_alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_cvar_handle_alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_cvar_handle_alloc_event_t stats_key_v = {};
            struct mpi_PMPI_T_cvar_handle_alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 488;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_cvar_handle_alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_cvar_handle_alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_cvar_handle_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_cvar_handle_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_cvar_handle_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_cvar_handle_free_event_t stats_key_v = {};
            struct mpi_PMPI_T_cvar_handle_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 489;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_cvar_handle_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_cvar_handle_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_cvar_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_cvar_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_cvar_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_cvar_read_event_t stats_key_v = {};
            struct mpi_PMPI_T_cvar_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 490;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_cvar_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_cvar_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_cvar_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_cvar_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_cvar_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_cvar_write_event_t stats_key_v = {};
            struct mpi_PMPI_T_cvar_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 491;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_cvar_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_cvar_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_enum_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_enum_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_enum_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_enum_get_info_event_t stats_key_v = {};
            struct mpi_PMPI_T_enum_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 492;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_enum_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_enum_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_enum_get_item_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_enum_get_item_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_enum_get_item_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_enum_get_item_event_t stats_key_v = {};
            struct mpi_PMPI_T_enum_get_item_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 493;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_enum_get_item_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_enum_get_item_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_finalize_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_finalize_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_finalize_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_finalize_event_t stats_key_v = {};
            struct mpi_PMPI_T_finalize_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 494;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_finalize_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_finalize_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_init_thread_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_init_thread_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_init_thread_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_init_thread_event_t stats_key_v = {};
            struct mpi_PMPI_T_init_thread_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 495;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_init_thread_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_init_thread_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_get_index_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_get_index_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_get_index_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_get_index_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_get_index_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 496;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_get_index_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_get_index_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_get_info_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 497;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_get_num_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_get_num_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_get_num_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_get_num_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_get_num_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 498;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_get_num_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_get_num_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_handle_alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_handle_alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_handle_alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_handle_alloc_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_handle_alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 499;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_handle_alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_handle_alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_handle_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_handle_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_handle_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_handle_free_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_handle_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 500;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_handle_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_handle_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_read_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 501;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_readreset_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_readreset_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_readreset_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_readreset_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_readreset_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 502;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_readreset_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_readreset_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_reset_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_reset_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_reset_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_reset_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_reset_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 503;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_reset_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_reset_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_session_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_session_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_session_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_session_create_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_session_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 504;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_session_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_session_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_session_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_session_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_session_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_session_free_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_session_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 505;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_session_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_session_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_start_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_start_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_start_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_start_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_start_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 506;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_start_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_start_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_stop_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_stop_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_stop_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_stop_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_stop_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 507;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_stop_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_stop_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_T_pvar_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_T_pvar_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_T_pvar_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_T_pvar_write_event_t stats_key_v = {};
            struct mpi_PMPI_T_pvar_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 508;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_T_pvar_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_T_pvar_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Test_event_t stats_key_v = {};
            struct mpi_PMPI_Test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 509;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Test_cancelled_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Test_cancelled_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Test_cancelled_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Test_cancelled_event_t stats_key_v = {};
            struct mpi_PMPI_Test_cancelled_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 510;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Test_cancelled_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Test_cancelled_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Testall_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Testall_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Testall_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Testall_event_t stats_key_v = {};
            struct mpi_PMPI_Testall_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 511;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Testall_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Testall_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Testany_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Testany_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Testany_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Testany_event_t stats_key_v = {};
            struct mpi_PMPI_Testany_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 512;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Testany_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Testany_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Testsome_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Testsome_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Testsome_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Testsome_event_t stats_key_v = {};
            struct mpi_PMPI_Testsome_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 513;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Testsome_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Testsome_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Topo_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Topo_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Topo_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Topo_test_event_t stats_key_v = {};
            struct mpi_PMPI_Topo_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 514;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Topo_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Topo_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Type_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 515;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_commit_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_commit_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_commit_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_commit_event_t stats_key_v = {};
            struct mpi_PMPI_Type_commit_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 516;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_commit_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_commit_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_contiguous_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_contiguous_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_contiguous_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_contiguous_event_t stats_key_v = {};
            struct mpi_PMPI_Type_contiguous_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 517;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_contiguous_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_contiguous_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_darray_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_darray_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_darray_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_darray_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_darray_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 518;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_darray_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_darray_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_f90_complex_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_f90_complex_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_f90_complex_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_f90_complex_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_f90_complex_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 519;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_f90_complex_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_f90_complex_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_f90_integer_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_f90_integer_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_f90_integer_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_f90_integer_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_f90_integer_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 520;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_f90_integer_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_f90_integer_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_f90_real_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_f90_real_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_f90_real_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_f90_real_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_f90_real_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 521;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_f90_real_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_f90_real_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_hindexed_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_hindexed_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_hindexed_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_hindexed_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_hindexed_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 522;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_hindexed_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_hindexed_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_hindexed_block_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_hindexed_block_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_hindexed_block_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_hindexed_block_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_hindexed_block_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 523;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_hindexed_block_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_hindexed_block_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_hvector_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_hvector_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_hvector_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_hvector_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_hvector_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 524;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_hvector_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_hvector_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_indexed_block_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_indexed_block_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_indexed_block_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_indexed_block_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_indexed_block_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 525;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_indexed_block_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_indexed_block_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_keyval_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_keyval_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_keyval_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_keyval_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_keyval_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 526;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_keyval_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_keyval_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_resized_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_resized_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_resized_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_resized_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_resized_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 527;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_resized_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_resized_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_struct_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_struct_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_struct_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_struct_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_struct_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 528;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_struct_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_struct_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_create_subarray_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_create_subarray_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_create_subarray_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_create_subarray_event_t stats_key_v = {};
            struct mpi_PMPI_Type_create_subarray_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 529;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_create_subarray_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_create_subarray_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_delete_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_delete_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_delete_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_delete_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Type_delete_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 530;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_delete_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_delete_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_dup_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_dup_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_dup_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_dup_event_t stats_key_v = {};
            struct mpi_PMPI_Type_dup_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 531;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_dup_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_dup_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_extent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_extent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_extent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_extent_event_t stats_key_v = {};
            struct mpi_PMPI_Type_extent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 532;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_extent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_extent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Type_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 533;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_free_event_t stats_key_v = {};
            struct mpi_PMPI_Type_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 534;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_free_keyval_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_free_keyval_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_free_keyval_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_free_keyval_event_t stats_key_v = {};
            struct mpi_PMPI_Type_free_keyval_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 535;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_free_keyval_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_free_keyval_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_get_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_get_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_get_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_get_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Type_get_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 536;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_get_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_get_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_get_contents_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_get_contents_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_get_contents_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_get_contents_event_t stats_key_v = {};
            struct mpi_PMPI_Type_get_contents_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 537;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_get_contents_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_get_contents_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_get_envelope_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_get_envelope_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_get_envelope_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_get_envelope_event_t stats_key_v = {};
            struct mpi_PMPI_Type_get_envelope_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 538;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_get_envelope_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_get_envelope_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_get_extent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_get_extent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_get_extent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_get_extent_event_t stats_key_v = {};
            struct mpi_PMPI_Type_get_extent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 539;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_get_extent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_get_extent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_get_extent_x_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_get_extent_x_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_get_extent_x_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_get_extent_x_event_t stats_key_v = {};
            struct mpi_PMPI_Type_get_extent_x_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 540;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_get_extent_x_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_get_extent_x_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_get_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_get_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_get_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_get_name_event_t stats_key_v = {};
            struct mpi_PMPI_Type_get_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 541;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_get_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_get_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_get_true_extent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_get_true_extent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_get_true_extent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_get_true_extent_event_t stats_key_v = {};
            struct mpi_PMPI_Type_get_true_extent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 542;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_get_true_extent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_get_true_extent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_get_true_extent_x_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_get_true_extent_x_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_get_true_extent_x_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_get_true_extent_x_event_t stats_key_v = {};
            struct mpi_PMPI_Type_get_true_extent_x_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 543;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_get_true_extent_x_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_get_true_extent_x_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_hindexed_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_hindexed_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_hindexed_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_hindexed_event_t stats_key_v = {};
            struct mpi_PMPI_Type_hindexed_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 544;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_hindexed_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_hindexed_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_hvector_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_hvector_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_hvector_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_hvector_event_t stats_key_v = {};
            struct mpi_PMPI_Type_hvector_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 545;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_hvector_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_hvector_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_indexed_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_indexed_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_indexed_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_indexed_event_t stats_key_v = {};
            struct mpi_PMPI_Type_indexed_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 546;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_indexed_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_indexed_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_lb_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_lb_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_lb_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_lb_event_t stats_key_v = {};
            struct mpi_PMPI_Type_lb_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 547;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_lb_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_lb_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_match_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_match_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_match_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_match_size_event_t stats_key_v = {};
            struct mpi_PMPI_Type_match_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 548;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_match_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_match_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_set_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_set_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_set_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_set_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Type_set_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 549;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_set_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_set_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_set_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_set_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_set_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_set_name_event_t stats_key_v = {};
            struct mpi_PMPI_Type_set_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 550;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_set_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_set_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_size_event_t stats_key_v = {};
            struct mpi_PMPI_Type_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 551;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_size_x_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_size_x_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_size_x_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_size_x_event_t stats_key_v = {};
            struct mpi_PMPI_Type_size_x_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 552;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_size_x_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_size_x_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_struct_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_struct_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_struct_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_struct_event_t stats_key_v = {};
            struct mpi_PMPI_Type_struct_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 553;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_struct_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_struct_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_ub_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_ub_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_ub_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_ub_event_t stats_key_v = {};
            struct mpi_PMPI_Type_ub_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 554;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_ub_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_ub_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Type_vector_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Type_vector_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Type_vector_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Type_vector_event_t stats_key_v = {};
            struct mpi_PMPI_Type_vector_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 555;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Type_vector_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Type_vector_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Unpack_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Unpack_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Unpack_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Unpack_event_t stats_key_v = {};
            struct mpi_PMPI_Unpack_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 556;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Unpack_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Unpack_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Unpack_external_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Unpack_external_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Unpack_external_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Unpack_external_event_t stats_key_v = {};
            struct mpi_PMPI_Unpack_external_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 557;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Unpack_external_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Unpack_external_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Unpublish_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Unpublish_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Unpublish_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Unpublish_name_event_t stats_key_v = {};
            struct mpi_PMPI_Unpublish_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 558;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Unpublish_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Unpublish_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Wait_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Wait_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Wait_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Wait_event_t stats_key_v = {};
            struct mpi_PMPI_Wait_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 559;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Wait_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Wait_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Waitall_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Waitall_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Waitall_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Waitall_event_t stats_key_v = {};
            struct mpi_PMPI_Waitall_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 560;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Waitall_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Waitall_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Waitany_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Waitany_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Waitany_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Waitany_event_t stats_key_v = {};
            struct mpi_PMPI_Waitany_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 561;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Waitany_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Waitany_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Waitsome_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Waitsome_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Waitsome_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Waitsome_event_t stats_key_v = {};
            struct mpi_PMPI_Waitsome_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 562;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Waitsome_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Waitsome_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_allocate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_allocate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_allocate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_allocate_event_t stats_key_v = {};
            struct mpi_PMPI_Win_allocate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 563;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_allocate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_allocate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_allocate_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_allocate_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_allocate_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_allocate_shared_event_t stats_key_v = {};
            struct mpi_PMPI_Win_allocate_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 564;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_allocate_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_allocate_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_attach_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_attach_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_attach_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_attach_event_t stats_key_v = {};
            struct mpi_PMPI_Win_attach_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 565;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_attach_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_attach_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_c2f_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_c2f_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_c2f_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_c2f_event_t stats_key_v = {};
            struct mpi_PMPI_Win_c2f_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 566;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_c2f_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_c2f_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_call_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_call_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_call_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_call_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Win_call_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 567;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_call_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_call_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_complete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_complete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_complete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_complete_event_t stats_key_v = {};
            struct mpi_PMPI_Win_complete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 568;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_complete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_complete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_create_event_t stats_key_v = {};
            struct mpi_PMPI_Win_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 569;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_create_dynamic_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_create_dynamic_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_create_dynamic_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_create_dynamic_event_t stats_key_v = {};
            struct mpi_PMPI_Win_create_dynamic_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 570;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_create_dynamic_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_create_dynamic_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_create_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_create_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_create_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_create_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Win_create_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 571;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_create_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_create_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_create_keyval_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_create_keyval_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_create_keyval_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_create_keyval_event_t stats_key_v = {};
            struct mpi_PMPI_Win_create_keyval_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 572;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_create_keyval_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_create_keyval_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_delete_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_delete_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_delete_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_delete_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Win_delete_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 573;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_delete_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_delete_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_detach_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_detach_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_detach_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_detach_event_t stats_key_v = {};
            struct mpi_PMPI_Win_detach_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 574;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_detach_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_detach_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_f2c_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_f2c_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_f2c_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_f2c_event_t stats_key_v = {};
            struct mpi_PMPI_Win_f2c_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 575;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_f2c_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_f2c_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_fence_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_fence_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_fence_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_fence_event_t stats_key_v = {};
            struct mpi_PMPI_Win_fence_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 576;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_fence_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_fence_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_flush_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_flush_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_flush_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_flush_event_t stats_key_v = {};
            struct mpi_PMPI_Win_flush_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 577;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_flush_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_flush_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_flush_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_flush_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_flush_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_flush_all_event_t stats_key_v = {};
            struct mpi_PMPI_Win_flush_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 578;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_flush_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_flush_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_flush_local_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_flush_local_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_flush_local_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_flush_local_event_t stats_key_v = {};
            struct mpi_PMPI_Win_flush_local_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 579;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_flush_local_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_flush_local_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_flush_local_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_flush_local_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_flush_local_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_flush_local_all_event_t stats_key_v = {};
            struct mpi_PMPI_Win_flush_local_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 580;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_flush_local_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_flush_local_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_free_event_t stats_key_v = {};
            struct mpi_PMPI_Win_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 581;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_free_keyval_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_free_keyval_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_free_keyval_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_free_keyval_event_t stats_key_v = {};
            struct mpi_PMPI_Win_free_keyval_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 582;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_free_keyval_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_free_keyval_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_get_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_get_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_get_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_get_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Win_get_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 583;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_get_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_get_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_get_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_get_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_get_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_get_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Win_get_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 584;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_get_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_get_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_get_group_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_get_group_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_get_group_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_get_group_event_t stats_key_v = {};
            struct mpi_PMPI_Win_get_group_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 585;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_get_group_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_get_group_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_get_info_event_t stats_key_v = {};
            struct mpi_PMPI_Win_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 586;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_get_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_get_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_get_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_get_name_event_t stats_key_v = {};
            struct mpi_PMPI_Win_get_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 587;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_get_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_get_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_lock_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_lock_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_lock_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_lock_event_t stats_key_v = {};
            struct mpi_PMPI_Win_lock_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 588;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_lock_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_lock_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_lock_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_lock_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_lock_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_lock_all_event_t stats_key_v = {};
            struct mpi_PMPI_Win_lock_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 589;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_lock_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_lock_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_post_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_post_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_post_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_post_event_t stats_key_v = {};
            struct mpi_PMPI_Win_post_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 590;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_post_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_post_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_set_attr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_set_attr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_set_attr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_set_attr_event_t stats_key_v = {};
            struct mpi_PMPI_Win_set_attr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 591;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_set_attr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_set_attr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_set_errhandler_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_set_errhandler_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_set_errhandler_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_set_errhandler_event_t stats_key_v = {};
            struct mpi_PMPI_Win_set_errhandler_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 592;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_set_errhandler_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_set_errhandler_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_set_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_set_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_set_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_set_info_event_t stats_key_v = {};
            struct mpi_PMPI_Win_set_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 593;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_set_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_set_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_set_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_set_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_set_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_set_name_event_t stats_key_v = {};
            struct mpi_PMPI_Win_set_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 594;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_set_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_set_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_shared_query_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_shared_query_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_shared_query_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_shared_query_event_t stats_key_v = {};
            struct mpi_PMPI_Win_shared_query_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 595;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_shared_query_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_shared_query_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_start_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_start_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_start_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_start_event_t stats_key_v = {};
            struct mpi_PMPI_Win_start_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 596;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_start_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_start_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_sync_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_sync_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_sync_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_sync_event_t stats_key_v = {};
            struct mpi_PMPI_Win_sync_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 597;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_sync_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_sync_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_test_event_t stats_key_v = {};
            struct mpi_PMPI_Win_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 598;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_unlock_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_unlock_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_unlock_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_unlock_event_t stats_key_v = {};
            struct mpi_PMPI_Win_unlock_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 599;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_unlock_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_unlock_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_unlock_all_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_unlock_all_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_unlock_all_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_unlock_all_event_t stats_key_v = {};
            struct mpi_PMPI_Win_unlock_all_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 600;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_unlock_all_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_unlock_all_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Win_wait_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Win_wait_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Win_wait_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Win_wait_event_t stats_key_v = {};
            struct mpi_PMPI_Win_wait_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 601;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Win_wait_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Win_wait_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Wtick_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Wtick_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Wtick_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Wtick_event_t stats_key_v = {};
            struct mpi_PMPI_Wtick_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 602;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Wtick_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Wtick_event_t), 0);
        
            return 0;
        }
        
        
        
            struct mpi_PMPI_Wtime_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_mpi_PMPI_Wtime_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_mpi_PMPI_Wtime_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct mpi_PMPI_Wtime_event_t stats_key_v = {};
            struct mpi_PMPI_Wtime_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 603;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct mpi_PMPI_Wtime_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct mpi_PMPI_Wtime_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__cmp_cparam_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__cmp_cparam_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__cmp_cparam_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__cmp_cparam_test_event_t stats_key_v = {};
            struct hdf5_H5FA__cmp_cparam_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 604;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__cmp_cparam_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__cmp_cparam_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__create_flush_depend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__create_flush_depend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__create_flush_depend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__create_flush_depend_event_t stats_key_v = {};
            struct hdf5_H5FA__create_flush_depend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 605;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__create_flush_depend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__create_flush_depend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblk_page_alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblk_page_alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblk_page_alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblk_page_alloc_event_t stats_key_v = {};
            struct hdf5_H5FA__dblk_page_alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 606;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblk_page_alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblk_page_alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblk_page_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblk_page_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblk_page_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblk_page_create_event_t stats_key_v = {};
            struct hdf5_H5FA__dblk_page_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 607;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblk_page_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblk_page_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblk_page_dest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblk_page_dest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblk_page_dest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblk_page_dest_event_t stats_key_v = {};
            struct hdf5_H5FA__dblk_page_dest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 608;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblk_page_dest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblk_page_dest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblk_page_protect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblk_page_protect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblk_page_protect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblk_page_protect_event_t stats_key_v = {};
            struct hdf5_H5FA__dblk_page_protect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 609;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblk_page_protect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblk_page_protect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblk_page_unprotect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblk_page_unprotect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblk_page_unprotect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblk_page_unprotect_event_t stats_key_v = {};
            struct hdf5_H5FA__dblk_page_unprotect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 610;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblk_page_unprotect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblk_page_unprotect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblock_alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblock_alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblock_alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblock_alloc_event_t stats_key_v = {};
            struct hdf5_H5FA__dblock_alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 611;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblock_alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblock_alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblock_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblock_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblock_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblock_create_event_t stats_key_v = {};
            struct hdf5_H5FA__dblock_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 612;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblock_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblock_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblock_debug_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblock_debug_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblock_debug_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblock_debug_event_t stats_key_v = {};
            struct hdf5_H5FA__dblock_debug_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 613;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblock_debug_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblock_debug_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblock_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblock_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblock_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblock_delete_event_t stats_key_v = {};
            struct hdf5_H5FA__dblock_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 614;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblock_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblock_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblock_dest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblock_dest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblock_dest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblock_dest_event_t stats_key_v = {};
            struct hdf5_H5FA__dblock_dest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 615;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblock_dest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblock_dest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblock_protect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblock_protect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblock_protect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblock_protect_event_t stats_key_v = {};
            struct hdf5_H5FA__dblock_protect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 616;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblock_protect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblock_protect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__dblock_unprotect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__dblock_unprotect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__dblock_unprotect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__dblock_unprotect_event_t stats_key_v = {};
            struct hdf5_H5FA__dblock_unprotect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 617;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__dblock_unprotect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__dblock_unprotect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__destroy_flush_depend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__destroy_flush_depend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__destroy_flush_depend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__destroy_flush_depend_event_t stats_key_v = {};
            struct hdf5_H5FA__destroy_flush_depend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 618;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__destroy_flush_depend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__destroy_flush_depend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__get_cparam_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__get_cparam_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__get_cparam_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__get_cparam_test_event_t stats_key_v = {};
            struct hdf5_H5FA__get_cparam_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 619;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__get_cparam_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__get_cparam_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_alloc_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 620;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_create_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 621;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_debug_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_debug_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_debug_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_debug_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_debug_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 622;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_debug_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_debug_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_decr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_decr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_decr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_decr_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_decr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 623;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_decr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_decr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_delete_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 624;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_dest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_dest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_dest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_dest_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_dest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 625;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_dest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_dest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_fuse_decr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_fuse_decr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_fuse_decr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_fuse_decr_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_fuse_decr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 626;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_fuse_decr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_fuse_decr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_fuse_incr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_fuse_incr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_fuse_incr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_fuse_incr_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_fuse_incr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 627;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_fuse_incr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_fuse_incr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_incr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_incr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_incr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_incr_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_incr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 628;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_incr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_incr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_init_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 629;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_modified_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_modified_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_modified_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_modified_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_modified_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 630;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_modified_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_modified_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_protect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_protect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_protect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_protect_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_protect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 631;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_protect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_protect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA__hdr_unprotect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA__hdr_unprotect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA__hdr_unprotect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA__hdr_unprotect_event_t stats_key_v = {};
            struct hdf5_H5FA__hdr_unprotect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 632;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA__hdr_unprotect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA__hdr_unprotect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_close_event_t stats_key_v = {};
            struct hdf5_H5FA_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 633;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_create_event_t stats_key_v = {};
            struct hdf5_H5FA_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 634;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_delete_event_t stats_key_v = {};
            struct hdf5_H5FA_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 635;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_depend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_depend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_depend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_depend_event_t stats_key_v = {};
            struct hdf5_H5FA_depend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 636;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_depend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_depend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_get_event_t stats_key_v = {};
            struct hdf5_H5FA_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 637;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_get_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_get_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_get_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_get_addr_event_t stats_key_v = {};
            struct hdf5_H5FA_get_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 638;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_get_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_get_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_get_nelmts_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_get_nelmts_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_get_nelmts_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_get_nelmts_event_t stats_key_v = {};
            struct hdf5_H5FA_get_nelmts_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 639;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_get_nelmts_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_get_nelmts_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_get_stats_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_get_stats_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_get_stats_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_get_stats_event_t stats_key_v = {};
            struct hdf5_H5FA_get_stats_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 640;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_get_stats_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_get_stats_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_iterate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_iterate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_iterate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_iterate_event_t stats_key_v = {};
            struct hdf5_H5FA_iterate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 641;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_iterate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_iterate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_open_event_t stats_key_v = {};
            struct hdf5_H5FA_open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 642;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_patch_file_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_patch_file_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_patch_file_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_patch_file_event_t stats_key_v = {};
            struct hdf5_H5FA_patch_file_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 643;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_patch_file_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_patch_file_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FA_set_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FA_set_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FA_set_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FA_set_event_t stats_key_v = {};
            struct hdf5_H5FA_set_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 644;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FA_set_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FA_set_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__alloc_real_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__alloc_real_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__alloc_real_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__alloc_real_event_t stats_key_v = {};
            struct hdf5_H5FD__alloc_real_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 645;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__alloc_real_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__alloc_real_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__free_real_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__free_real_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__free_real_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__free_real_event_t stats_key_v = {};
            struct hdf5_H5FD__free_real_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 646;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__free_real_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__free_real_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_archival_index_find_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_archival_index_find_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_archival_index_find_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_archival_index_find_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_archival_index_find_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 647;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_archival_index_find_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_archival_index_find_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_archival_index_is_valid_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_archival_index_is_valid_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_archival_index_is_valid_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_archival_index_is_valid_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_archival_index_is_valid_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 648;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_archival_index_is_valid_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_archival_index_is_valid_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_header_decode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_header_decode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_header_decode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_header_decode_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_header_decode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 649;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_header_decode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_header_decode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_header_encode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_header_encode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_header_encode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_header_encode_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_header_encode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 650;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_header_encode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_header_encode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_history_decode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_history_decode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_history_decode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_history_decode_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_history_decode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 651;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_history_decode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_history_decode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_history_encode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_history_encode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_history_encode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_history_encode_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_history_encode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 652;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_history_encode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_history_encode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_ingest_header_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_ingest_header_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_ingest_header_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_ingest_header_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_ingest_header_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 653;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_ingest_header_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_ingest_header_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_ingest_history_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_ingest_history_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_ingest_history_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_ingest_history_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_ingest_history_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 654;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_ingest_history_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_ingest_history_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_ingest_revision_record_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_ingest_revision_record_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_ingest_revision_record_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_ingest_revision_record_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_ingest_revision_record_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 655;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_ingest_revision_record_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_ingest_revision_record_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_merge_revision_index_into_archival_index_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_merge_revision_index_into_archival_index_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_merge_revision_index_into_archival_index_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_merge_revision_index_into_archival_index_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_merge_revision_index_into_archival_index_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 656;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_merge_revision_index_into_archival_index_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_merge_revision_index_into_archival_index_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_revision_index_destroy_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_revision_index_destroy_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_revision_index_destroy_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_revision_index_destroy_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_revision_index_destroy_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 657;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_revision_index_destroy_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_revision_index_destroy_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_revision_index_find_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_revision_index_find_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_revision_index_find_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_revision_index_find_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_revision_index_find_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 658;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_revision_index_find_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_revision_index_find_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_revision_index_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_revision_index_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_revision_index_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_revision_index_init_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_revision_index_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 659;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_revision_index_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_revision_index_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_revision_index_insert_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_revision_index_insert_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_revision_index_insert_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_revision_index_insert_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_revision_index_insert_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 660;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_revision_index_insert_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_revision_index_insert_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_revision_record_decode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_revision_record_decode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_revision_record_decode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_revision_record_decode_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_revision_record_decode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 661;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_revision_record_decode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_revision_record_decode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_revision_record_encode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_revision_record_encode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_revision_record_encode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_revision_record_encode_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_revision_record_encode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 662;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_revision_record_encode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_revision_record_encode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_write_final_history_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_write_final_history_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_write_final_history_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_write_final_history_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_write_final_history_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 663;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_write_final_history_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_write_final_history_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_write_header_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_write_header_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_write_header_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_write_header_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_write_header_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 664;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_write_header_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_write_header_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__onion_write_history_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__onion_write_history_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__onion_write_history_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__onion_write_history_event_t stats_key_v = {};
            struct hdf5_H5FD__onion_write_history_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 665;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__onion_write_history_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__onion_write_history_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD__supports_swmr_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD__supports_swmr_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD__supports_swmr_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD__supports_swmr_test_event_t stats_key_v = {};
            struct hdf5_H5FD__supports_swmr_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 666;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD__supports_swmr_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD__supports_swmr_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_alloc_event_t stats_key_v = {};
            struct hdf5_H5FD_alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 667;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_check_plugin_load_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_check_plugin_load_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_check_plugin_load_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_check_plugin_load_event_t stats_key_v = {};
            struct hdf5_H5FD_check_plugin_load_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 668;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_check_plugin_load_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_check_plugin_load_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_close_event_t stats_key_v = {};
            struct hdf5_H5FD_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 669;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_cmp_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_cmp_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_cmp_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_cmp_event_t stats_key_v = {};
            struct hdf5_H5FD_cmp_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 670;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_cmp_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_cmp_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_core_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_core_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_core_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_core_init_event_t stats_key_v = {};
            struct hdf5_H5FD_core_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 671;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_core_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_core_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_ctl_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_ctl_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_ctl_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_ctl_event_t stats_key_v = {};
            struct hdf5_H5FD_ctl_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 672;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_ctl_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_ctl_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_delete_event_t stats_key_v = {};
            struct hdf5_H5FD_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 673;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_driver_query_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_driver_query_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_driver_query_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_driver_query_event_t stats_key_v = {};
            struct hdf5_H5FD_driver_query_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 674;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_driver_query_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_driver_query_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_family_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_family_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_family_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_family_init_event_t stats_key_v = {};
            struct hdf5_H5FD_family_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 675;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_family_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_family_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_fapl_get_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_fapl_get_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_fapl_get_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_fapl_get_event_t stats_key_v = {};
            struct hdf5_H5FD_fapl_get_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 676;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_fapl_get_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_fapl_get_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_flush_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_flush_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_flush_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_flush_event_t stats_key_v = {};
            struct hdf5_H5FD_flush_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 677;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_flush_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_flush_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_free_event_t stats_key_v = {};
            struct hdf5_H5FD_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 678;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_free_driver_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_free_driver_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_free_driver_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_free_driver_info_event_t stats_key_v = {};
            struct hdf5_H5FD_free_driver_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 679;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_free_driver_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_free_driver_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_base_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_base_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_base_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_base_addr_event_t stats_key_v = {};
            struct hdf5_H5FD_get_base_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 680;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_base_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_base_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_class_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_class_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_class_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_class_event_t stats_key_v = {};
            struct hdf5_H5FD_get_class_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 681;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_class_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_class_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_driver_id_by_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_driver_id_by_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_driver_id_by_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_driver_id_by_name_event_t stats_key_v = {};
            struct hdf5_H5FD_get_driver_id_by_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 682;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_driver_id_by_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_driver_id_by_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_driver_id_by_value_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_driver_id_by_value_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_driver_id_by_value_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_driver_id_by_value_event_t stats_key_v = {};
            struct hdf5_H5FD_get_driver_id_by_value_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 683;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_driver_id_by_value_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_driver_id_by_value_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_eoa_event_t stats_key_v = {};
            struct hdf5_H5FD_get_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 684;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_eof_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_eof_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_eof_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_eof_event_t stats_key_v = {};
            struct hdf5_H5FD_get_eof_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 685;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_eof_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_eof_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_feature_flags_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_feature_flags_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_feature_flags_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_feature_flags_event_t stats_key_v = {};
            struct hdf5_H5FD_get_feature_flags_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 686;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_feature_flags_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_feature_flags_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_fileno_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_fileno_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_fileno_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_fileno_event_t stats_key_v = {};
            struct hdf5_H5FD_get_fileno_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 687;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_fileno_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_fileno_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_fs_type_map_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_fs_type_map_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_fs_type_map_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_fs_type_map_event_t stats_key_v = {};
            struct hdf5_H5FD_get_fs_type_map_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 688;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_fs_type_map_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_fs_type_map_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_maxaddr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_maxaddr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_maxaddr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_maxaddr_event_t stats_key_v = {};
            struct hdf5_H5FD_get_maxaddr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 689;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_maxaddr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_maxaddr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_mpio_atomicity_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_mpio_atomicity_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_mpio_atomicity_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_mpio_atomicity_event_t stats_key_v = {};
            struct hdf5_H5FD_get_mpio_atomicity_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 690;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_mpio_atomicity_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_mpio_atomicity_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_get_vfd_handle_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_get_vfd_handle_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_get_vfd_handle_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_get_vfd_handle_event_t stats_key_v = {};
            struct hdf5_H5FD_get_vfd_handle_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 691;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_get_vfd_handle_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_get_vfd_handle_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_init_event_t stats_key_v = {};
            struct hdf5_H5FD_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 692;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_is_driver_registered_by_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_is_driver_registered_by_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_is_driver_registered_by_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_is_driver_registered_by_name_event_t stats_key_v = {};
            struct hdf5_H5FD_is_driver_registered_by_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 693;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_is_driver_registered_by_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_is_driver_registered_by_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_is_driver_registered_by_value_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_is_driver_registered_by_value_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_is_driver_registered_by_value_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_is_driver_registered_by_value_event_t stats_key_v = {};
            struct hdf5_H5FD_is_driver_registered_by_value_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 694;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_is_driver_registered_by_value_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_is_driver_registered_by_value_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_locate_signature_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_locate_signature_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_locate_signature_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_locate_signature_event_t stats_key_v = {};
            struct hdf5_H5FD_locate_signature_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 695;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_locate_signature_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_locate_signature_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_lock_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_lock_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_lock_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_lock_event_t stats_key_v = {};
            struct hdf5_H5FD_lock_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 696;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_lock_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_lock_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_log_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_log_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_log_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_log_init_event_t stats_key_v = {};
            struct hdf5_H5FD_log_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 697;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_log_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_log_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_mpi_MPIOff_to_haddr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_mpi_MPIOff_to_haddr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_mpi_MPIOff_to_haddr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_mpi_MPIOff_to_haddr_event_t stats_key_v = {};
            struct hdf5_H5FD_mpi_MPIOff_to_haddr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 698;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_mpi_MPIOff_to_haddr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_mpi_MPIOff_to_haddr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_mpi_get_comm_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_mpi_get_comm_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_mpi_get_comm_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_mpi_get_comm_event_t stats_key_v = {};
            struct hdf5_H5FD_mpi_get_comm_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 699;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_mpi_get_comm_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_mpi_get_comm_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_mpi_get_file_sync_required_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_mpi_get_file_sync_required_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_mpi_get_file_sync_required_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_mpi_get_file_sync_required_event_t stats_key_v = {};
            struct hdf5_H5FD_mpi_get_file_sync_required_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 700;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_mpi_get_file_sync_required_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_mpi_get_file_sync_required_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_mpi_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_mpi_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_mpi_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_mpi_get_info_event_t stats_key_v = {};
            struct hdf5_H5FD_mpi_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 701;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_mpi_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_mpi_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_mpi_get_rank_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_mpi_get_rank_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_mpi_get_rank_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_mpi_get_rank_event_t stats_key_v = {};
            struct hdf5_H5FD_mpi_get_rank_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 702;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_mpi_get_rank_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_mpi_get_rank_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_mpi_get_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_mpi_get_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_mpi_get_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_mpi_get_size_event_t stats_key_v = {};
            struct hdf5_H5FD_mpi_get_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 703;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_mpi_get_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_mpi_get_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_mpi_haddr_to_MPIOff_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_mpi_haddr_to_MPIOff_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_mpi_haddr_to_MPIOff_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_mpi_haddr_to_MPIOff_event_t stats_key_v = {};
            struct hdf5_H5FD_mpi_haddr_to_MPIOff_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 704;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_mpi_haddr_to_MPIOff_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_mpi_haddr_to_MPIOff_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_mpio_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_mpio_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_mpio_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_mpio_init_event_t stats_key_v = {};
            struct hdf5_H5FD_mpio_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 705;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_mpio_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_mpio_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_multi_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_multi_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_multi_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_multi_init_event_t stats_key_v = {};
            struct hdf5_H5FD_multi_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 706;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_multi_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_multi_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_onion_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_onion_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_onion_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_onion_init_event_t stats_key_v = {};
            struct hdf5_H5FD_onion_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 707;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_onion_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_onion_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_open_event_t stats_key_v = {};
            struct hdf5_H5FD_open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 708;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_read_event_t stats_key_v = {};
            struct hdf5_H5FD_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 709;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_read_from_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_read_from_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_read_from_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_read_from_selection_event_t stats_key_v = {};
            struct hdf5_H5FD_read_from_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 710;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_read_from_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_read_from_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_read_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_read_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_read_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_read_selection_event_t stats_key_v = {};
            struct hdf5_H5FD_read_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 711;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_read_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_read_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_read_selection_id_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_read_selection_id_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_read_selection_id_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_read_selection_id_event_t stats_key_v = {};
            struct hdf5_H5FD_read_selection_id_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 712;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_read_selection_id_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_read_selection_id_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_read_vector_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_read_vector_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_read_vector_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_read_vector_event_t stats_key_v = {};
            struct hdf5_H5FD_read_vector_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 713;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_read_vector_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_read_vector_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_read_vector_from_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_read_vector_from_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_read_vector_from_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_read_vector_from_selection_event_t stats_key_v = {};
            struct hdf5_H5FD_read_vector_from_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 714;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_read_vector_from_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_read_vector_from_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_register_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_register_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_register_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_register_event_t stats_key_v = {};
            struct hdf5_H5FD_register_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 715;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_register_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_register_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_register_driver_by_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_register_driver_by_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_register_driver_by_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_register_driver_by_name_event_t stats_key_v = {};
            struct hdf5_H5FD_register_driver_by_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 716;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_register_driver_by_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_register_driver_by_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_register_driver_by_value_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_register_driver_by_value_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_register_driver_by_value_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_register_driver_by_value_event_t stats_key_v = {};
            struct hdf5_H5FD_register_driver_by_value_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 717;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_register_driver_by_value_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_register_driver_by_value_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_sb_encode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_sb_encode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_sb_encode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_sb_encode_event_t stats_key_v = {};
            struct hdf5_H5FD_sb_encode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 718;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_sb_encode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_sb_encode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_sb_load_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_sb_load_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_sb_load_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_sb_load_event_t stats_key_v = {};
            struct hdf5_H5FD_sb_load_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 719;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_sb_load_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_sb_load_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_sb_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_sb_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_sb_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_sb_size_event_t stats_key_v = {};
            struct hdf5_H5FD_sb_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 720;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_sb_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_sb_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_sec2_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_sec2_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_sec2_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_sec2_init_event_t stats_key_v = {};
            struct hdf5_H5FD_sec2_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 721;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_sec2_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_sec2_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_set_base_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_set_base_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_set_base_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_set_base_addr_event_t stats_key_v = {};
            struct hdf5_H5FD_set_base_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 722;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_set_base_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_set_base_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_set_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_set_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_set_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_set_eoa_event_t stats_key_v = {};
            struct hdf5_H5FD_set_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 723;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_set_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_set_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_set_feature_flags_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_set_feature_flags_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_set_feature_flags_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_set_feature_flags_event_t stats_key_v = {};
            struct hdf5_H5FD_set_feature_flags_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 724;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_set_feature_flags_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_set_feature_flags_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_set_mpio_atomicity_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_set_mpio_atomicity_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_set_mpio_atomicity_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_set_mpio_atomicity_event_t stats_key_v = {};
            struct hdf5_H5FD_set_mpio_atomicity_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 725;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_set_mpio_atomicity_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_set_mpio_atomicity_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_set_paged_aggr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_set_paged_aggr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_set_paged_aggr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_set_paged_aggr_event_t stats_key_v = {};
            struct hdf5_H5FD_set_paged_aggr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 726;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_set_paged_aggr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_set_paged_aggr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_sort_selection_io_req_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_sort_selection_io_req_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_sort_selection_io_req_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_sort_selection_io_req_event_t stats_key_v = {};
            struct hdf5_H5FD_sort_selection_io_req_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 727;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_sort_selection_io_req_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_sort_selection_io_req_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_sort_vector_io_req_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_sort_vector_io_req_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_sort_vector_io_req_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_sort_vector_io_req_event_t stats_key_v = {};
            struct hdf5_H5FD_sort_vector_io_req_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 728;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_sort_vector_io_req_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_sort_vector_io_req_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_splitter_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_splitter_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_splitter_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_splitter_init_event_t stats_key_v = {};
            struct hdf5_H5FD_splitter_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 729;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_splitter_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_splitter_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_stdio_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_stdio_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_stdio_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_stdio_init_event_t stats_key_v = {};
            struct hdf5_H5FD_stdio_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 730;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_stdio_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_stdio_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_term_package_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_term_package_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_term_package_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_term_package_event_t stats_key_v = {};
            struct hdf5_H5FD_term_package_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 731;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_term_package_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_term_package_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_truncate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_truncate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_truncate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_truncate_event_t stats_key_v = {};
            struct hdf5_H5FD_truncate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 732;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_truncate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_truncate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_try_extend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_try_extend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_try_extend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_try_extend_event_t stats_key_v = {};
            struct hdf5_H5FD_try_extend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 733;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_try_extend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_try_extend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_unlock_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_unlock_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_unlock_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_unlock_event_t stats_key_v = {};
            struct hdf5_H5FD_unlock_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 734;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_unlock_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_unlock_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_write_event_t stats_key_v = {};
            struct hdf5_H5FD_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 735;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_write_from_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_write_from_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_write_from_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_write_from_selection_event_t stats_key_v = {};
            struct hdf5_H5FD_write_from_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 736;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_write_from_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_write_from_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_write_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_write_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_write_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_write_selection_event_t stats_key_v = {};
            struct hdf5_H5FD_write_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 737;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_write_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_write_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_write_selection_id_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_write_selection_id_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_write_selection_id_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_write_selection_id_event_t stats_key_v = {};
            struct hdf5_H5FD_write_selection_id_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 738;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_write_selection_id_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_write_selection_id_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_write_vector_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_write_vector_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_write_vector_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_write_vector_event_t stats_key_v = {};
            struct hdf5_H5FD_write_vector_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 739;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_write_vector_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_write_vector_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FD_write_vector_from_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FD_write_vector_from_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FD_write_vector_from_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FD_write_vector_from_selection_event_t stats_key_v = {};
            struct hdf5_H5FD_write_vector_from_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 740;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FD_write_vector_from_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FD_write_vector_from_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDalloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDalloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDalloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDalloc_event_t stats_key_v = {};
            struct hdf5_H5FDalloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 741;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDalloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDalloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDclose_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDclose_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDclose_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDclose_event_t stats_key_v = {};
            struct hdf5_H5FDclose_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 742;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDclose_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDclose_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDcmp_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDcmp_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDcmp_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDcmp_event_t stats_key_v = {};
            struct hdf5_H5FDcmp_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 743;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDcmp_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDcmp_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDctl_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDctl_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDctl_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDctl_event_t stats_key_v = {};
            struct hdf5_H5FDctl_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 744;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDctl_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDctl_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDdelete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDdelete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDdelete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDdelete_event_t stats_key_v = {};
            struct hdf5_H5FDdelete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 745;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDdelete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDdelete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDdriver_query_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDdriver_query_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDdriver_query_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDdriver_query_event_t stats_key_v = {};
            struct hdf5_H5FDdriver_query_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 746;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDdriver_query_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDdriver_query_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDflush_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDflush_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDflush_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDflush_event_t stats_key_v = {};
            struct hdf5_H5FDflush_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 747;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDflush_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDflush_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDfree_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDfree_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDfree_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDfree_event_t stats_key_v = {};
            struct hdf5_H5FDfree_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 748;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDfree_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDfree_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDget_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDget_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDget_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDget_eoa_event_t stats_key_v = {};
            struct hdf5_H5FDget_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 749;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDget_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDget_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDget_eof_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDget_eof_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDget_eof_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDget_eof_event_t stats_key_v = {};
            struct hdf5_H5FDget_eof_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 750;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDget_eof_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDget_eof_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDget_vfd_handle_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDget_vfd_handle_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDget_vfd_handle_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDget_vfd_handle_event_t stats_key_v = {};
            struct hdf5_H5FDget_vfd_handle_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 751;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDget_vfd_handle_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDget_vfd_handle_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDis_driver_registered_by_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDis_driver_registered_by_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDis_driver_registered_by_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDis_driver_registered_by_name_event_t stats_key_v = {};
            struct hdf5_H5FDis_driver_registered_by_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 752;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDis_driver_registered_by_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDis_driver_registered_by_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDis_driver_registered_by_value_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDis_driver_registered_by_value_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDis_driver_registered_by_value_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDis_driver_registered_by_value_event_t stats_key_v = {};
            struct hdf5_H5FDis_driver_registered_by_value_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 753;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDis_driver_registered_by_value_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDis_driver_registered_by_value_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDlock_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDlock_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDlock_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDlock_event_t stats_key_v = {};
            struct hdf5_H5FDlock_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 754;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDlock_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDlock_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDonion_get_revision_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDonion_get_revision_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDonion_get_revision_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDonion_get_revision_count_event_t stats_key_v = {};
            struct hdf5_H5FDonion_get_revision_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 755;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDonion_get_revision_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDonion_get_revision_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDopen_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDopen_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDopen_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDopen_event_t stats_key_v = {};
            struct hdf5_H5FDopen_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 756;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDopen_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDopen_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDperform_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDperform_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDperform_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDperform_init_event_t stats_key_v = {};
            struct hdf5_H5FDperform_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 757;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDperform_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDperform_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDquery_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDquery_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDquery_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDquery_event_t stats_key_v = {};
            struct hdf5_H5FDquery_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 758;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDquery_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDquery_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDread_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDread_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDread_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDread_event_t stats_key_v = {};
            struct hdf5_H5FDread_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 759;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDread_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDread_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDread_from_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDread_from_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDread_from_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDread_from_selection_event_t stats_key_v = {};
            struct hdf5_H5FDread_from_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 760;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDread_from_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDread_from_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDread_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDread_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDread_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDread_selection_event_t stats_key_v = {};
            struct hdf5_H5FDread_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 761;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDread_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDread_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDread_vector_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDread_vector_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDread_vector_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDread_vector_event_t stats_key_v = {};
            struct hdf5_H5FDread_vector_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 762;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDread_vector_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDread_vector_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDread_vector_from_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDread_vector_from_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDread_vector_from_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDread_vector_from_selection_event_t stats_key_v = {};
            struct hdf5_H5FDread_vector_from_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 763;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDread_vector_from_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDread_vector_from_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDregister_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDregister_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDregister_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDregister_event_t stats_key_v = {};
            struct hdf5_H5FDregister_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 764;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDregister_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDregister_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDset_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDset_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDset_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDset_eoa_event_t stats_key_v = {};
            struct hdf5_H5FDset_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 765;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDset_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDset_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDtruncate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDtruncate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDtruncate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDtruncate_event_t stats_key_v = {};
            struct hdf5_H5FDtruncate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 766;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDtruncate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDtruncate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDunlock_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDunlock_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDunlock_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDunlock_event_t stats_key_v = {};
            struct hdf5_H5FDunlock_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 767;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDunlock_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDunlock_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDunregister_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDunregister_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDunregister_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDunregister_event_t stats_key_v = {};
            struct hdf5_H5FDunregister_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 768;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDunregister_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDunregister_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDwrite_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDwrite_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDwrite_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDwrite_event_t stats_key_v = {};
            struct hdf5_H5FDwrite_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 769;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDwrite_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDwrite_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDwrite_from_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDwrite_from_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDwrite_from_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDwrite_from_selection_event_t stats_key_v = {};
            struct hdf5_H5FDwrite_from_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 770;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDwrite_from_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDwrite_from_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDwrite_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDwrite_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDwrite_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDwrite_selection_event_t stats_key_v = {};
            struct hdf5_H5FDwrite_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 771;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDwrite_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDwrite_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDwrite_vector_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDwrite_vector_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDwrite_vector_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDwrite_vector_event_t stats_key_v = {};
            struct hdf5_H5FDwrite_vector_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 772;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDwrite_vector_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDwrite_vector_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FDwrite_vector_from_selection_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FDwrite_vector_from_selection_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FDwrite_vector_from_selection_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FDwrite_vector_from_selection_event_t stats_key_v = {};
            struct hdf5_H5FDwrite_vector_from_selection_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 773;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FDwrite_vector_from_selection_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FDwrite_vector_from_selection_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_arr_calloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_arr_calloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_arr_calloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_arr_calloc_event_t stats_key_v = {};
            struct hdf5_H5FL_arr_calloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 774;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_arr_calloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_arr_calloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_arr_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_arr_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_arr_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_arr_free_event_t stats_key_v = {};
            struct hdf5_H5FL_arr_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 775;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_arr_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_arr_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_arr_malloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_arr_malloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_arr_malloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_arr_malloc_event_t stats_key_v = {};
            struct hdf5_H5FL_arr_malloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 776;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_arr_malloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_arr_malloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_arr_realloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_arr_realloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_arr_realloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_arr_realloc_event_t stats_key_v = {};
            struct hdf5_H5FL_arr_realloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 777;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_arr_realloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_arr_realloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_blk_calloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_blk_calloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_blk_calloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_blk_calloc_event_t stats_key_v = {};
            struct hdf5_H5FL_blk_calloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 778;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_blk_calloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_blk_calloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_blk_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_blk_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_blk_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_blk_free_event_t stats_key_v = {};
            struct hdf5_H5FL_blk_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 779;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_blk_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_blk_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_blk_free_block_avail_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_blk_free_block_avail_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_blk_free_block_avail_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_blk_free_block_avail_event_t stats_key_v = {};
            struct hdf5_H5FL_blk_free_block_avail_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 780;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_blk_free_block_avail_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_blk_free_block_avail_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_blk_malloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_blk_malloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_blk_malloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_blk_malloc_event_t stats_key_v = {};
            struct hdf5_H5FL_blk_malloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 781;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_blk_malloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_blk_malloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_blk_realloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_blk_realloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_blk_realloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_blk_realloc_event_t stats_key_v = {};
            struct hdf5_H5FL_blk_realloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 782;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_blk_realloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_blk_realloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_fac_calloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_fac_calloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_fac_calloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_fac_calloc_event_t stats_key_v = {};
            struct hdf5_H5FL_fac_calloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 783;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_fac_calloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_fac_calloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_fac_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_fac_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_fac_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_fac_free_event_t stats_key_v = {};
            struct hdf5_H5FL_fac_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 784;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_fac_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_fac_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_fac_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_fac_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_fac_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_fac_init_event_t stats_key_v = {};
            struct hdf5_H5FL_fac_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 785;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_fac_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_fac_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_fac_malloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_fac_malloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_fac_malloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_fac_malloc_event_t stats_key_v = {};
            struct hdf5_H5FL_fac_malloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 786;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_fac_malloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_fac_malloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_fac_term_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_fac_term_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_fac_term_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_fac_term_event_t stats_key_v = {};
            struct hdf5_H5FL_fac_term_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 787;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_fac_term_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_fac_term_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_garbage_coll_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_garbage_coll_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_garbage_coll_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_garbage_coll_event_t stats_key_v = {};
            struct hdf5_H5FL_garbage_coll_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 788;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_garbage_coll_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_garbage_coll_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_get_free_list_sizes_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_get_free_list_sizes_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_get_free_list_sizes_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_get_free_list_sizes_event_t stats_key_v = {};
            struct hdf5_H5FL_get_free_list_sizes_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 789;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_get_free_list_sizes_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_get_free_list_sizes_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_reg_calloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_reg_calloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_reg_calloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_reg_calloc_event_t stats_key_v = {};
            struct hdf5_H5FL_reg_calloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 790;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_reg_calloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_reg_calloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_reg_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_reg_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_reg_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_reg_free_event_t stats_key_v = {};
            struct hdf5_H5FL_reg_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 791;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_reg_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_reg_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_reg_malloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_reg_malloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_reg_malloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_reg_malloc_event_t stats_key_v = {};
            struct hdf5_H5FL_reg_malloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 792;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_reg_malloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_reg_malloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_seq_calloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_seq_calloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_seq_calloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_seq_calloc_event_t stats_key_v = {};
            struct hdf5_H5FL_seq_calloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 793;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_seq_calloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_seq_calloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_seq_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_seq_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_seq_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_seq_free_event_t stats_key_v = {};
            struct hdf5_H5FL_seq_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 794;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_seq_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_seq_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_seq_malloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_seq_malloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_seq_malloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_seq_malloc_event_t stats_key_v = {};
            struct hdf5_H5FL_seq_malloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 795;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_seq_malloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_seq_malloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_seq_realloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_seq_realloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_seq_realloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_seq_realloc_event_t stats_key_v = {};
            struct hdf5_H5FL_seq_realloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 796;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_seq_realloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_seq_realloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_set_free_list_limits_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_set_free_list_limits_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_set_free_list_limits_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_set_free_list_limits_event_t stats_key_v = {};
            struct hdf5_H5FL_set_free_list_limits_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 797;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_set_free_list_limits_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_set_free_list_limits_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FL_term_package_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FL_term_package_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FL_term_package_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FL_term_package_event_t stats_key_v = {};
            struct hdf5_H5FL_term_package_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 798;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FL_term_package_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FL_term_package_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_create_event_t stats_key_v = {};
            struct hdf5_H5FO_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 799;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_delete_event_t stats_key_v = {};
            struct hdf5_H5FO_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 800;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_dest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_dest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_dest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_dest_event_t stats_key_v = {};
            struct hdf5_H5FO_dest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 801;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_dest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_dest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_insert_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_insert_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_insert_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_insert_event_t stats_key_v = {};
            struct hdf5_H5FO_insert_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 802;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_insert_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_insert_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_mark_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_mark_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_mark_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_mark_event_t stats_key_v = {};
            struct hdf5_H5FO_mark_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 803;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_mark_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_mark_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_marked_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_marked_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_marked_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_marked_event_t stats_key_v = {};
            struct hdf5_H5FO_marked_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 804;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_marked_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_marked_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_opened_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_opened_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_opened_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_opened_event_t stats_key_v = {};
            struct hdf5_H5FO_opened_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 805;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_opened_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_opened_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_top_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_top_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_top_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_top_count_event_t stats_key_v = {};
            struct hdf5_H5FO_top_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 806;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_top_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_top_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_top_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_top_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_top_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_top_create_event_t stats_key_v = {};
            struct hdf5_H5FO_top_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 807;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_top_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_top_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_top_decr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_top_decr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_top_decr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_top_decr_event_t stats_key_v = {};
            struct hdf5_H5FO_top_decr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 808;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_top_decr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_top_decr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_top_dest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_top_dest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_top_dest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_top_dest_event_t stats_key_v = {};
            struct hdf5_H5FO_top_dest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 809;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_top_dest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_top_dest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FO_top_incr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FO_top_incr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FO_top_incr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FO_top_incr_event_t stats_key_v = {};
            struct hdf5_H5FO_top_incr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 810;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FO_top_incr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FO_top_incr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__cmp_cparam_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__cmp_cparam_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__cmp_cparam_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__cmp_cparam_test_event_t stats_key_v = {};
            struct hdf5_H5FS__cmp_cparam_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 811;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__cmp_cparam_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__cmp_cparam_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__create_flush_depend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__create_flush_depend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__create_flush_depend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__create_flush_depend_event_t stats_key_v = {};
            struct hdf5_H5FS__create_flush_depend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 812;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__create_flush_depend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__create_flush_depend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__decr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__decr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__decr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__decr_event_t stats_key_v = {};
            struct hdf5_H5FS__decr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 813;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__decr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__decr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__destroy_flush_depend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__destroy_flush_depend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__destroy_flush_depend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__destroy_flush_depend_event_t stats_key_v = {};
            struct hdf5_H5FS__destroy_flush_depend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 814;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__destroy_flush_depend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__destroy_flush_depend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__dirty_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__dirty_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__dirty_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__dirty_event_t stats_key_v = {};
            struct hdf5_H5FS__dirty_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 815;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__dirty_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__dirty_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__get_cparam_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__get_cparam_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__get_cparam_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__get_cparam_test_event_t stats_key_v = {};
            struct hdf5_H5FS__get_cparam_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 816;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__get_cparam_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__get_cparam_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__hdr_dest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__hdr_dest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__hdr_dest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__hdr_dest_event_t stats_key_v = {};
            struct hdf5_H5FS__hdr_dest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 817;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__hdr_dest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__hdr_dest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__incr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__incr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__incr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__incr_event_t stats_key_v = {};
            struct hdf5_H5FS__incr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 818;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__incr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__incr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__new_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__new_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__new_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__new_event_t stats_key_v = {};
            struct hdf5_H5FS__new_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 819;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__new_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__new_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__sinfo_dest_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__sinfo_dest_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__sinfo_dest_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__sinfo_dest_event_t stats_key_v = {};
            struct hdf5_H5FS__sinfo_dest_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 820;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__sinfo_dest_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__sinfo_dest_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS__sinfo_new_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS__sinfo_new_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS__sinfo_new_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS__sinfo_new_event_t stats_key_v = {};
            struct hdf5_H5FS__sinfo_new_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 821;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS__sinfo_new_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS__sinfo_new_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_alloc_hdr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_alloc_hdr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_alloc_hdr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_alloc_hdr_event_t stats_key_v = {};
            struct hdf5_H5FS_alloc_hdr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 822;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_alloc_hdr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_alloc_hdr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_alloc_sect_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_alloc_sect_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_alloc_sect_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_alloc_sect_event_t stats_key_v = {};
            struct hdf5_H5FS_alloc_sect_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 823;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_alloc_sect_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_alloc_sect_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_close_event_t stats_key_v = {};
            struct hdf5_H5FS_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 824;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_create_event_t stats_key_v = {};
            struct hdf5_H5FS_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 825;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_debug_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_debug_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_debug_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_debug_event_t stats_key_v = {};
            struct hdf5_H5FS_debug_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 826;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_debug_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_debug_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_delete_event_t stats_key_v = {};
            struct hdf5_H5FS_delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 827;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_free_event_t stats_key_v = {};
            struct hdf5_H5FS_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 828;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_get_sect_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_get_sect_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_get_sect_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_get_sect_count_event_t stats_key_v = {};
            struct hdf5_H5FS_get_sect_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 829;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_get_sect_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_get_sect_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_open_event_t stats_key_v = {};
            struct hdf5_H5FS_open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 830;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_add_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_add_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_add_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_add_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_add_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 831;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_add_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_add_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_change_class_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_change_class_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_change_class_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_change_class_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_change_class_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 832;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_change_class_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_change_class_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_debug_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_debug_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_debug_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_debug_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_debug_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 833;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_debug_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_debug_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_find_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_find_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_find_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_find_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_find_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 834;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_find_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_find_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_iterate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_iterate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_iterate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_iterate_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_iterate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 835;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_iterate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_iterate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_remove_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_remove_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_remove_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_remove_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_remove_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 836;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_remove_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_remove_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_stats_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_stats_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_stats_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_stats_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_stats_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 837;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_stats_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_stats_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_try_extend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_try_extend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_try_extend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_try_extend_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_try_extend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 838;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_try_extend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_try_extend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_try_merge_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_try_merge_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_try_merge_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_try_merge_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_try_merge_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 839;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_try_merge_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_try_merge_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sect_try_shrink_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sect_try_shrink_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sect_try_shrink_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sect_try_shrink_eoa_event_t stats_key_v = {};
            struct hdf5_H5FS_sect_try_shrink_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 840;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sect_try_shrink_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sect_try_shrink_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_sects_debug_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_sects_debug_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_sects_debug_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_sects_debug_event_t stats_key_v = {};
            struct hdf5_H5FS_sects_debug_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 841;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_sects_debug_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_sects_debug_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_size_event_t stats_key_v = {};
            struct hdf5_H5FS_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 842;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_stat_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_stat_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_stat_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_stat_info_event_t stats_key_v = {};
            struct hdf5_H5FS_stat_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 843;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_stat_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_stat_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5FS_vfd_alloc_hdr_and_section_info_if_needed_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5FS_vfd_alloc_hdr_and_section_info_if_needed_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5FS_vfd_alloc_hdr_and_section_info_if_needed_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5FS_vfd_alloc_hdr_and_section_info_if_needed_event_t stats_key_v = {};
            struct hdf5_H5FS_vfd_alloc_hdr_and_section_info_if_needed_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 844;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5FS_vfd_alloc_hdr_and_section_info_if_needed_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5FS_vfd_alloc_hdr_and_section_info_if_needed_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_Kvalue_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_Kvalue_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_Kvalue_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_Kvalue_event_t stats_key_v = {};
            struct hdf5_H5F_Kvalue_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 845;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_Kvalue_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_Kvalue_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__accum_flush_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__accum_flush_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__accum_flush_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__accum_flush_event_t stats_key_v = {};
            struct hdf5_H5F__accum_flush_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 846;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__accum_flush_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__accum_flush_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__accum_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__accum_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__accum_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__accum_free_event_t stats_key_v = {};
            struct hdf5_H5F__accum_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 847;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__accum_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__accum_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__accum_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__accum_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__accum_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__accum_read_event_t stats_key_v = {};
            struct hdf5_H5F__accum_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 848;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__accum_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__accum_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__accum_reset_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__accum_reset_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__accum_reset_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__accum_reset_event_t stats_key_v = {};
            struct hdf5_H5F__accum_reset_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 849;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__accum_reset_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__accum_reset_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__accum_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__accum_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__accum_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__accum_write_event_t stats_key_v = {};
            struct hdf5_H5F__accum_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 850;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__accum_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__accum_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__alloc_event_t stats_key_v = {};
            struct hdf5_H5F__alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 851;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__check_cached_stab_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__check_cached_stab_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__check_cached_stab_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__check_cached_stab_test_event_t stats_key_v = {};
            struct hdf5_H5F__check_cached_stab_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 852;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__check_cached_stab_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__check_cached_stab_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__close_event_t stats_key_v = {};
            struct hdf5_H5F__close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 853;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__close_mounts_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__close_mounts_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__close_mounts_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__close_mounts_event_t stats_key_v = {};
            struct hdf5_H5F__close_mounts_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 854;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__close_mounts_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__close_mounts_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__delete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__delete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__delete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__delete_event_t stats_key_v = {};
            struct hdf5_H5F__delete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 855;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__delete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__delete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__efc_create_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__efc_create_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__efc_create_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__efc_create_event_t stats_key_v = {};
            struct hdf5_H5F__efc_create_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 856;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__efc_create_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__efc_create_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__efc_destroy_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__efc_destroy_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__efc_destroy_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__efc_destroy_event_t stats_key_v = {};
            struct hdf5_H5F__efc_destroy_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 857;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__efc_destroy_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__efc_destroy_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__efc_max_nfiles_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__efc_max_nfiles_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__efc_max_nfiles_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__efc_max_nfiles_event_t stats_key_v = {};
            struct hdf5_H5F__efc_max_nfiles_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 858;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__efc_max_nfiles_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__efc_max_nfiles_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__efc_open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__efc_open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__efc_open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__efc_open_event_t stats_key_v = {};
            struct hdf5_H5F__efc_open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 859;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__efc_open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__efc_open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__efc_release_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__efc_release_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__efc_release_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__efc_release_event_t stats_key_v = {};
            struct hdf5_H5F__efc_release_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 860;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__efc_release_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__efc_release_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__efc_try_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__efc_try_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__efc_try_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__efc_try_close_event_t stats_key_v = {};
            struct hdf5_H5F__efc_try_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 861;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__efc_try_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__efc_try_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__evict_cache_entries_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__evict_cache_entries_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__evict_cache_entries_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__evict_cache_entries_event_t stats_key_v = {};
            struct hdf5_H5F__evict_cache_entries_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 862;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__evict_cache_entries_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__evict_cache_entries_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__flush_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__flush_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__flush_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__flush_event_t stats_key_v = {};
            struct hdf5_H5F__flush_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 863;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__flush_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__flush_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__format_convert_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__format_convert_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__format_convert_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__format_convert_event_t stats_key_v = {};
            struct hdf5_H5F__format_convert_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 864;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__format_convert_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__format_convert_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__free_event_t stats_key_v = {};
            struct hdf5_H5F__free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 865;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__get_cont_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__get_cont_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__get_cont_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__get_cont_info_event_t stats_key_v = {};
            struct hdf5_H5F__get_cont_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 866;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__get_cont_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__get_cont_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__get_file_image_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__get_file_image_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__get_file_image_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__get_file_image_event_t stats_key_v = {};
            struct hdf5_H5F__get_file_image_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 867;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__get_file_image_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__get_file_image_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__get_info_event_t stats_key_v = {};
            struct hdf5_H5F__get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 868;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__get_max_eof_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__get_max_eof_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__get_max_eof_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__get_max_eof_eoa_event_t stats_key_v = {};
            struct hdf5_H5F__get_max_eof_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 869;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__get_max_eof_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__get_max_eof_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__get_maxaddr_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__get_maxaddr_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__get_maxaddr_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__get_maxaddr_test_event_t stats_key_v = {};
            struct hdf5_H5F__get_maxaddr_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 870;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__get_maxaddr_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__get_maxaddr_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__get_mpi_atomicity_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__get_mpi_atomicity_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__get_mpi_atomicity_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__get_mpi_atomicity_event_t stats_key_v = {};
            struct hdf5_H5F__get_mpi_atomicity_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 871;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__get_mpi_atomicity_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__get_mpi_atomicity_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__get_sbe_addr_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__get_sbe_addr_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__get_sbe_addr_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__get_sbe_addr_test_event_t stats_key_v = {};
            struct hdf5_H5F__get_sbe_addr_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 872;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__get_sbe_addr_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__get_sbe_addr_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__get_sohm_mesg_count_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__get_sohm_mesg_count_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__get_sohm_mesg_count_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__get_sohm_mesg_count_test_event_t stats_key_v = {};
            struct hdf5_H5F__get_sohm_mesg_count_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 873;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__get_sohm_mesg_count_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__get_sohm_mesg_count_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__is_hdf5_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__is_hdf5_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__is_hdf5_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__is_hdf5_event_t stats_key_v = {};
            struct hdf5_H5F__is_hdf5_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 874;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__is_hdf5_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__is_hdf5_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__mount_count_ids_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__mount_count_ids_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__mount_count_ids_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__mount_count_ids_event_t stats_key_v = {};
            struct hdf5_H5F__mount_count_ids_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 875;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__mount_count_ids_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__mount_count_ids_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__parse_file_lock_env_var_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__parse_file_lock_env_var_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__parse_file_lock_env_var_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__parse_file_lock_env_var_event_t stats_key_v = {};
            struct hdf5_H5F__parse_file_lock_env_var_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 876;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__parse_file_lock_env_var_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__parse_file_lock_env_var_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__post_open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__post_open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__post_open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__post_open_event_t stats_key_v = {};
            struct hdf5_H5F__post_open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 877;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__post_open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__post_open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__reopen_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__reopen_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__reopen_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__reopen_event_t stats_key_v = {};
            struct hdf5_H5F__reopen_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 878;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__reopen_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__reopen_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__reparse_file_lock_variable_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__reparse_file_lock_variable_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__reparse_file_lock_variable_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__reparse_file_lock_variable_test_event_t stats_key_v = {};
            struct hdf5_H5F__reparse_file_lock_variable_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 879;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__reparse_file_lock_variable_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__reparse_file_lock_variable_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__same_file_test_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__same_file_test_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__same_file_test_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__same_file_test_event_t stats_key_v = {};
            struct hdf5_H5F__same_file_test_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 880;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__same_file_test_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__same_file_test_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__set_base_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__set_base_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__set_base_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__set_base_addr_event_t stats_key_v = {};
            struct hdf5_H5F__set_base_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 881;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__set_base_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__set_base_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__set_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__set_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__set_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__set_eoa_event_t stats_key_v = {};
            struct hdf5_H5F__set_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 882;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__set_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__set_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__set_libver_bounds_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__set_libver_bounds_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__set_libver_bounds_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__set_libver_bounds_event_t stats_key_v = {};
            struct hdf5_H5F__set_libver_bounds_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 883;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__set_libver_bounds_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__set_libver_bounds_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__set_mpi_atomicity_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__set_mpi_atomicity_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__set_mpi_atomicity_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__set_mpi_atomicity_event_t stats_key_v = {};
            struct hdf5_H5F__set_mpi_atomicity_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 884;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__set_mpi_atomicity_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__set_mpi_atomicity_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__set_paged_aggr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__set_paged_aggr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__set_paged_aggr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__set_paged_aggr_event_t stats_key_v = {};
            struct hdf5_H5F__set_paged_aggr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 885;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__set_paged_aggr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__set_paged_aggr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__sfile_add_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__sfile_add_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__sfile_add_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__sfile_add_event_t stats_key_v = {};
            struct hdf5_H5F__sfile_add_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 886;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__sfile_add_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__sfile_add_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__sfile_remove_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__sfile_remove_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__sfile_remove_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__sfile_remove_event_t stats_key_v = {};
            struct hdf5_H5F__sfile_remove_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 887;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__sfile_remove_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__sfile_remove_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__sfile_search_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__sfile_search_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__sfile_search_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__sfile_search_event_t stats_key_v = {};
            struct hdf5_H5F__sfile_search_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 888;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__sfile_search_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__sfile_search_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__start_swmr_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__start_swmr_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__start_swmr_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__start_swmr_write_event_t stats_key_v = {};
            struct hdf5_H5F__start_swmr_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 889;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__start_swmr_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__start_swmr_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__super_ext_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__super_ext_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__super_ext_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__super_ext_close_event_t stats_key_v = {};
            struct hdf5_H5F__super_ext_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 890;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__super_ext_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__super_ext_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__super_ext_open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__super_ext_open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__super_ext_open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__super_ext_open_event_t stats_key_v = {};
            struct hdf5_H5F__super_ext_open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 891;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__super_ext_open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__super_ext_open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__super_ext_remove_msg_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__super_ext_remove_msg_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__super_ext_remove_msg_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__super_ext_remove_msg_event_t stats_key_v = {};
            struct hdf5_H5F__super_ext_remove_msg_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 892;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__super_ext_remove_msg_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__super_ext_remove_msg_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__super_ext_write_msg_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__super_ext_write_msg_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__super_ext_write_msg_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__super_ext_write_msg_event_t stats_key_v = {};
            struct hdf5_H5F__super_ext_write_msg_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 893;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__super_ext_write_msg_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__super_ext_write_msg_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__super_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__super_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__super_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__super_free_event_t stats_key_v = {};
            struct hdf5_H5F__super_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 894;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__super_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__super_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__super_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__super_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__super_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__super_init_event_t stats_key_v = {};
            struct hdf5_H5F__super_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 895;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__super_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__super_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__super_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__super_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__super_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__super_read_event_t stats_key_v = {};
            struct hdf5_H5F__super_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 896;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__super_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__super_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__super_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__super_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__super_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__super_size_event_t stats_key_v = {};
            struct hdf5_H5F__super_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 897;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__super_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__super_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F__try_extend_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F__try_extend_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F__try_extend_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F__try_extend_event_t stats_key_v = {};
            struct hdf5_H5F__try_extend_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 898;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F__try_extend_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F__try_extend_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_addr_decode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_addr_decode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_addr_decode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_addr_decode_event_t stats_key_v = {};
            struct hdf5_H5F_addr_decode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 899;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_addr_decode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_addr_decode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_addr_decode_len_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_addr_decode_len_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_addr_decode_len_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_addr_decode_len_event_t stats_key_v = {};
            struct hdf5_H5F_addr_decode_len_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 900;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_addr_decode_len_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_addr_decode_len_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_addr_encode_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_addr_encode_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_addr_encode_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_addr_encode_event_t stats_key_v = {};
            struct hdf5_H5F_addr_encode_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 901;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_addr_encode_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_addr_encode_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_addr_encode_len_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_addr_encode_len_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_addr_encode_len_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_addr_encode_len_event_t stats_key_v = {};
            struct hdf5_H5F_addr_encode_len_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 902;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_addr_encode_len_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_addr_encode_len_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_block_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_block_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_block_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_block_read_event_t stats_key_v = {};
            struct hdf5_H5F_block_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 903;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_block_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_block_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_block_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_block_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_block_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_block_write_event_t stats_key_v = {};
            struct hdf5_H5F_block_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 904;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_block_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_block_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_coll_md_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_coll_md_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_coll_md_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_coll_md_read_event_t stats_key_v = {};
            struct hdf5_H5F_coll_md_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 905;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_coll_md_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_coll_md_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_cwfs_add_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_cwfs_add_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_cwfs_add_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_cwfs_add_event_t stats_key_v = {};
            struct hdf5_H5F_cwfs_add_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 906;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_cwfs_add_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_cwfs_add_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_cwfs_advance_heap_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_cwfs_advance_heap_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_cwfs_advance_heap_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_cwfs_advance_heap_event_t stats_key_v = {};
            struct hdf5_H5F_cwfs_advance_heap_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 907;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_cwfs_advance_heap_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_cwfs_advance_heap_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_cwfs_find_free_heap_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_cwfs_find_free_heap_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_cwfs_find_free_heap_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_cwfs_find_free_heap_event_t stats_key_v = {};
            struct hdf5_H5F_cwfs_find_free_heap_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 908;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_cwfs_find_free_heap_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_cwfs_find_free_heap_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_cwfs_remove_heap_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_cwfs_remove_heap_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_cwfs_remove_heap_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_cwfs_remove_heap_event_t stats_key_v = {};
            struct hdf5_H5F_cwfs_remove_heap_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 909;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_cwfs_remove_heap_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_cwfs_remove_heap_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_debug_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_debug_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_debug_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_debug_event_t stats_key_v = {};
            struct hdf5_H5F_debug_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 910;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_debug_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_debug_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_decr_nopen_objs_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_decr_nopen_objs_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_decr_nopen_objs_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_decr_nopen_objs_event_t stats_key_v = {};
            struct hdf5_H5F_decr_nopen_objs_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 911;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_decr_nopen_objs_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_decr_nopen_objs_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_efc_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_efc_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_efc_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_efc_close_event_t stats_key_v = {};
            struct hdf5_H5F_efc_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 912;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_efc_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_efc_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_eoa_dirty_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_eoa_dirty_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_eoa_dirty_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_eoa_dirty_event_t stats_key_v = {};
            struct hdf5_H5F_eoa_dirty_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 913;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_eoa_dirty_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_eoa_dirty_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_fake_alloc_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_fake_alloc_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_fake_alloc_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_fake_alloc_event_t stats_key_v = {};
            struct hdf5_H5F_fake_alloc_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 914;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_fake_alloc_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_fake_alloc_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_fake_free_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_fake_free_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_fake_free_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_fake_free_event_t stats_key_v = {};
            struct hdf5_H5F_fake_free_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 915;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_fake_free_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_fake_free_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_file_id_exists_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_file_id_exists_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_file_id_exists_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_file_id_exists_event_t stats_key_v = {};
            struct hdf5_H5F_file_id_exists_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 916;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_file_id_exists_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_file_id_exists_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_flush_mounts_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_flush_mounts_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_flush_mounts_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_flush_mounts_event_t stats_key_v = {};
            struct hdf5_H5F_flush_mounts_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 917;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_flush_mounts_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_flush_mounts_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_flush_tagged_metadata_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_flush_tagged_metadata_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_flush_tagged_metadata_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_flush_tagged_metadata_event_t stats_key_v = {};
            struct hdf5_H5F_flush_tagged_metadata_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 918;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_flush_tagged_metadata_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_flush_tagged_metadata_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_gc_ref_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_gc_ref_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_gc_ref_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_gc_ref_event_t stats_key_v = {};
            struct hdf5_H5F_gc_ref_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 919;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_gc_ref_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_gc_ref_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_access_plist_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_access_plist_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_access_plist_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_access_plist_event_t stats_key_v = {};
            struct hdf5_H5F_get_access_plist_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 920;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_access_plist_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_access_plist_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_actual_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_actual_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_actual_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_actual_name_event_t stats_key_v = {};
            struct hdf5_H5F_get_actual_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 921;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_actual_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_actual_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_alignment_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_alignment_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_alignment_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_alignment_event_t stats_key_v = {};
            struct hdf5_H5F_get_alignment_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 922;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_alignment_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_alignment_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_base_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_base_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_base_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_base_addr_event_t stats_key_v = {};
            struct hdf5_H5F_get_base_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 923;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_base_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_base_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_checksums_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_checksums_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_checksums_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_checksums_event_t stats_key_v = {};
            struct hdf5_H5F_get_checksums_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 924;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_checksums_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_checksums_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_coll_metadata_reads_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_coll_metadata_reads_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_coll_metadata_reads_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_coll_metadata_reads_event_t stats_key_v = {};
            struct hdf5_H5F_get_coll_metadata_reads_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 925;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_coll_metadata_reads_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_coll_metadata_reads_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_driver_id_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_driver_id_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_driver_id_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_driver_id_event_t stats_key_v = {};
            struct hdf5_H5F_get_driver_id_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 926;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_driver_id_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_driver_id_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_eoa_event_t stats_key_v = {};
            struct hdf5_H5F_get_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 927;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_evict_on_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_evict_on_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_evict_on_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_evict_on_close_event_t stats_key_v = {};
            struct hdf5_H5F_get_evict_on_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 928;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_evict_on_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_evict_on_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_extpath_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_extpath_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_extpath_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_extpath_event_t stats_key_v = {};
            struct hdf5_H5F_get_extpath_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 929;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_extpath_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_extpath_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_fc_degree_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_fc_degree_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_fc_degree_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_fc_degree_event_t stats_key_v = {};
            struct hdf5_H5F_get_fc_degree_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 930;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_fc_degree_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_fc_degree_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_fcpl_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_fcpl_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_fcpl_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_fcpl_event_t stats_key_v = {};
            struct hdf5_H5F_get_fcpl_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 931;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_fcpl_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_fcpl_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_file_id_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_file_id_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_file_id_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_file_id_event_t stats_key_v = {};
            struct hdf5_H5F_get_file_id_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 932;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_file_id_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_file_id_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_fileno_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_fileno_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_fileno_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_fileno_event_t stats_key_v = {};
            struct hdf5_H5F_get_fileno_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 933;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_fileno_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_fileno_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_high_bound_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_high_bound_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_high_bound_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_high_bound_event_t stats_key_v = {};
            struct hdf5_H5F_get_high_bound_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 934;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_high_bound_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_high_bound_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_id_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_id_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_id_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_id_event_t stats_key_v = {};
            struct hdf5_H5F_get_id_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 935;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_id_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_id_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_intent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_intent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_intent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_intent_event_t stats_key_v = {};
            struct hdf5_H5F_get_intent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 936;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_intent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_intent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_low_bound_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_low_bound_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_low_bound_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_low_bound_event_t stats_key_v = {};
            struct hdf5_H5F_get_low_bound_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 937;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_low_bound_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_low_bound_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_metadata_read_retry_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_metadata_read_retry_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_metadata_read_retry_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_metadata_read_retry_info_event_t stats_key_v = {};
            struct hdf5_H5F_get_metadata_read_retry_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 938;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_metadata_read_retry_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_metadata_read_retry_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_min_dset_ohdr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_min_dset_ohdr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_min_dset_ohdr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_min_dset_ohdr_event_t stats_key_v = {};
            struct hdf5_H5F_get_min_dset_ohdr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 939;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_min_dset_ohdr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_min_dset_ohdr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_nmounts_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_nmounts_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_nmounts_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_nmounts_event_t stats_key_v = {};
            struct hdf5_H5F_get_nmounts_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 940;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_nmounts_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_nmounts_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_nopen_objs_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_nopen_objs_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_nopen_objs_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_nopen_objs_event_t stats_key_v = {};
            struct hdf5_H5F_get_nopen_objs_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 941;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_nopen_objs_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_nopen_objs_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_nrefs_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_nrefs_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_nrefs_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_nrefs_event_t stats_key_v = {};
            struct hdf5_H5F_get_nrefs_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 942;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_nrefs_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_nrefs_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_null_fsm_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_null_fsm_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_null_fsm_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_null_fsm_addr_event_t stats_key_v = {};
            struct hdf5_H5F_get_null_fsm_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 943;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_null_fsm_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_null_fsm_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_obj_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_obj_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_obj_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_obj_count_event_t stats_key_v = {};
            struct hdf5_H5F_get_obj_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 944;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_obj_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_obj_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_obj_ids_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_obj_ids_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_obj_ids_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_obj_ids_event_t stats_key_v = {};
            struct hdf5_H5F_get_obj_ids_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 945;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_obj_ids_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_obj_ids_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_open_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_open_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_open_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_open_name_event_t stats_key_v = {};
            struct hdf5_H5F_get_open_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 946;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_open_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_open_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_parent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_parent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_parent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_parent_event_t stats_key_v = {};
            struct hdf5_H5F_get_parent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 947;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_parent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_parent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_pgend_meta_thres_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_pgend_meta_thres_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_pgend_meta_thres_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_pgend_meta_thres_event_t stats_key_v = {};
            struct hdf5_H5F_get_pgend_meta_thres_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 948;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_pgend_meta_thres_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_pgend_meta_thres_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_point_of_no_return_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_point_of_no_return_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_point_of_no_return_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_point_of_no_return_event_t stats_key_v = {};
            struct hdf5_H5F_get_point_of_no_return_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 949;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_point_of_no_return_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_point_of_no_return_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_read_attempts_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_read_attempts_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_read_attempts_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_read_attempts_event_t stats_key_v = {};
            struct hdf5_H5F_get_read_attempts_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 950;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_read_attempts_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_read_attempts_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_rfic_flags_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_rfic_flags_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_rfic_flags_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_rfic_flags_event_t stats_key_v = {};
            struct hdf5_H5F_get_rfic_flags_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 951;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_rfic_flags_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_rfic_flags_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_shared_event_t stats_key_v = {};
            struct hdf5_H5F_get_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 952;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_sohm_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_sohm_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_sohm_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_sohm_addr_event_t stats_key_v = {};
            struct hdf5_H5F_get_sohm_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 953;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_sohm_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_sohm_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_sohm_nindexes_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_sohm_nindexes_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_sohm_nindexes_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_sohm_nindexes_event_t stats_key_v = {};
            struct hdf5_H5F_get_sohm_nindexes_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 954;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_sohm_nindexes_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_sohm_nindexes_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_sohm_vers_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_sohm_vers_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_sohm_vers_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_sohm_vers_event_t stats_key_v = {};
            struct hdf5_H5F_get_sohm_vers_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 955;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_sohm_vers_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_sohm_vers_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_threshold_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_threshold_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_threshold_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_threshold_event_t stats_key_v = {};
            struct hdf5_H5F_get_threshold_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 956;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_threshold_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_threshold_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_use_file_locking_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_use_file_locking_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_use_file_locking_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_use_file_locking_event_t stats_key_v = {};
            struct hdf5_H5F_get_use_file_locking_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 957;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_use_file_locking_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_use_file_locking_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_vfd_handle_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_vfd_handle_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_vfd_handle_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_vfd_handle_event_t stats_key_v = {};
            struct hdf5_H5F_get_vfd_handle_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 958;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_vfd_handle_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_vfd_handle_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_vol_cls_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_vol_cls_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_vol_cls_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_vol_cls_event_t stats_key_v = {};
            struct hdf5_H5F_get_vol_cls_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 959;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_vol_cls_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_vol_cls_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_get_vol_obj_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_get_vol_obj_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_get_vol_obj_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_get_vol_obj_event_t stats_key_v = {};
            struct hdf5_H5F_get_vol_obj_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 960;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_get_vol_obj_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_get_vol_obj_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_grp_btree_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_grp_btree_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_grp_btree_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_grp_btree_shared_event_t stats_key_v = {};
            struct hdf5_H5F_grp_btree_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 961;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_grp_btree_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_grp_btree_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_has_feature_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_has_feature_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_has_feature_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_has_feature_event_t stats_key_v = {};
            struct hdf5_H5F_has_feature_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 962;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_has_feature_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_has_feature_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_has_vector_select_io_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_has_vector_select_io_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_has_vector_select_io_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_has_vector_select_io_event_t stats_key_v = {};
            struct hdf5_H5F_has_vector_select_io_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 963;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_has_vector_select_io_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_has_vector_select_io_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_incr_nopen_objs_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_incr_nopen_objs_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_incr_nopen_objs_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_incr_nopen_objs_event_t stats_key_v = {};
            struct hdf5_H5F_incr_nopen_objs_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 964;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_incr_nopen_objs_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_incr_nopen_objs_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_init_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_init_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_init_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_init_event_t stats_key_v = {};
            struct hdf5_H5F_init_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 965;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_init_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_init_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_is_mount_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_is_mount_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_is_mount_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_is_mount_event_t stats_key_v = {};
            struct hdf5_H5F_is_mount_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 966;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_is_mount_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_is_mount_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_is_tmp_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_is_tmp_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_is_tmp_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_is_tmp_addr_event_t stats_key_v = {};
            struct hdf5_H5F_is_tmp_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 967;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_is_tmp_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_is_tmp_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_mdc_log_location_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_mdc_log_location_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_mdc_log_location_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_mdc_log_location_event_t stats_key_v = {};
            struct hdf5_H5F_mdc_log_location_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 968;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_mdc_log_location_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_mdc_log_location_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_mount_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_mount_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_mount_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_mount_event_t stats_key_v = {};
            struct hdf5_H5F_mount_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 969;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_mount_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_mount_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_mpi_get_comm_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_mpi_get_comm_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_mpi_get_comm_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_mpi_get_comm_event_t stats_key_v = {};
            struct hdf5_H5F_mpi_get_comm_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 970;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_mpi_get_comm_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_mpi_get_comm_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_mpi_get_file_block_type_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_mpi_get_file_block_type_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_mpi_get_file_block_type_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_mpi_get_file_block_type_event_t stats_key_v = {};
            struct hdf5_H5F_mpi_get_file_block_type_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 971;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_mpi_get_file_block_type_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_mpi_get_file_block_type_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_mpi_get_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_mpi_get_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_mpi_get_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_mpi_get_info_event_t stats_key_v = {};
            struct hdf5_H5F_mpi_get_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 972;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_mpi_get_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_mpi_get_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_mpi_get_rank_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_mpi_get_rank_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_mpi_get_rank_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_mpi_get_rank_event_t stats_key_v = {};
            struct hdf5_H5F_mpi_get_rank_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 973;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_mpi_get_rank_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_mpi_get_rank_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_mpi_get_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_mpi_get_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_mpi_get_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_mpi_get_size_event_t stats_key_v = {};
            struct hdf5_H5F_mpi_get_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 974;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_mpi_get_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_mpi_get_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_mpi_retrieve_comm_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_mpi_retrieve_comm_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_mpi_retrieve_comm_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_mpi_retrieve_comm_event_t stats_key_v = {};
            struct hdf5_H5F_mpi_retrieve_comm_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 975;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_mpi_retrieve_comm_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_mpi_retrieve_comm_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_object_flush_cb_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_object_flush_cb_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_object_flush_cb_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_object_flush_cb_event_t stats_key_v = {};
            struct hdf5_H5F_object_flush_cb_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 976;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_object_flush_cb_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_object_flush_cb_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_open_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_open_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_open_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_open_event_t stats_key_v = {};
            struct hdf5_H5F_open_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 977;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_open_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_open_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_prefix_open_file_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_prefix_open_file_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_prefix_open_file_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_prefix_open_file_event_t stats_key_v = {};
            struct hdf5_H5F_prefix_open_file_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 978;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_prefix_open_file_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_prefix_open_file_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_rdcc_nbytes_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_rdcc_nbytes_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_rdcc_nbytes_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_rdcc_nbytes_event_t stats_key_v = {};
            struct hdf5_H5F_rdcc_nbytes_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 979;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_rdcc_nbytes_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_rdcc_nbytes_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_rdcc_nslots_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_rdcc_nslots_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_rdcc_nslots_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_rdcc_nslots_event_t stats_key_v = {};
            struct hdf5_H5F_rdcc_nslots_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 980;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_rdcc_nslots_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_rdcc_nslots_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_rdcc_w0_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_rdcc_w0_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_rdcc_w0_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_rdcc_w0_event_t stats_key_v = {};
            struct hdf5_H5F_rdcc_w0_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 981;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_rdcc_w0_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_rdcc_w0_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_same_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_same_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_same_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_same_shared_event_t stats_key_v = {};
            struct hdf5_H5F_same_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 982;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_same_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_same_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_set_coll_metadata_reads_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_set_coll_metadata_reads_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_set_coll_metadata_reads_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_set_coll_metadata_reads_event_t stats_key_v = {};
            struct hdf5_H5F_set_coll_metadata_reads_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 983;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_set_coll_metadata_reads_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_set_coll_metadata_reads_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_set_grp_btree_shared_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_set_grp_btree_shared_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_set_grp_btree_shared_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_set_grp_btree_shared_event_t stats_key_v = {};
            struct hdf5_H5F_set_grp_btree_shared_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 984;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_set_grp_btree_shared_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_set_grp_btree_shared_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_set_min_dset_ohdr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_set_min_dset_ohdr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_set_min_dset_ohdr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_set_min_dset_ohdr_event_t stats_key_v = {};
            struct hdf5_H5F_set_min_dset_ohdr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 985;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_set_min_dset_ohdr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_set_min_dset_ohdr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_set_retries_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_set_retries_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_set_retries_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_set_retries_event_t stats_key_v = {};
            struct hdf5_H5F_set_retries_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 986;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_set_retries_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_set_retries_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_set_sohm_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_set_sohm_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_set_sohm_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_set_sohm_addr_event_t stats_key_v = {};
            struct hdf5_H5F_set_sohm_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 987;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_set_sohm_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_set_sohm_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_set_sohm_nindexes_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_set_sohm_nindexes_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_set_sohm_nindexes_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_set_sohm_nindexes_event_t stats_key_v = {};
            struct hdf5_H5F_set_sohm_nindexes_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 988;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_set_sohm_nindexes_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_set_sohm_nindexes_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_set_sohm_vers_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_set_sohm_vers_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_set_sohm_vers_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_set_sohm_vers_event_t stats_key_v = {};
            struct hdf5_H5F_set_sohm_vers_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 989;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_set_sohm_vers_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_set_sohm_vers_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_set_store_msg_crt_idx_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_set_store_msg_crt_idx_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_set_store_msg_crt_idx_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_set_store_msg_crt_idx_event_t stats_key_v = {};
            struct hdf5_H5F_set_store_msg_crt_idx_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 990;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_set_store_msg_crt_idx_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_set_store_msg_crt_idx_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_sfile_assert_num_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_sfile_assert_num_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_sfile_assert_num_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_sfile_assert_num_event_t stats_key_v = {};
            struct hdf5_H5F_sfile_assert_num_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 991;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_sfile_assert_num_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_sfile_assert_num_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_block_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_block_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_block_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_block_read_event_t stats_key_v = {};
            struct hdf5_H5F_shared_block_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 992;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_block_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_block_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_block_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_block_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_block_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_block_write_event_t stats_key_v = {};
            struct hdf5_H5F_shared_block_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 993;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_block_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_block_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_coll_md_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_coll_md_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_coll_md_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_coll_md_read_event_t stats_key_v = {};
            struct hdf5_H5F_shared_coll_md_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 994;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_coll_md_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_coll_md_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_get_coll_metadata_reads_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_get_coll_metadata_reads_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_get_coll_metadata_reads_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_get_coll_metadata_reads_event_t stats_key_v = {};
            struct hdf5_H5F_shared_get_coll_metadata_reads_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 995;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_get_coll_metadata_reads_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_get_coll_metadata_reads_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_get_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_get_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_get_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_get_eoa_event_t stats_key_v = {};
            struct hdf5_H5F_shared_get_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 996;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_get_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_get_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_get_file_driver_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_get_file_driver_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_get_file_driver_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_get_file_driver_event_t stats_key_v = {};
            struct hdf5_H5F_shared_get_file_driver_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 997;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_get_file_driver_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_get_file_driver_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_get_intent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_get_intent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_get_intent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_get_intent_event_t stats_key_v = {};
            struct hdf5_H5F_shared_get_intent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 998;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_get_intent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_get_intent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_get_mpi_file_sync_required_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_get_mpi_file_sync_required_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_get_mpi_file_sync_required_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_get_mpi_file_sync_required_event_t stats_key_v = {};
            struct hdf5_H5F_shared_get_mpi_file_sync_required_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 999;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_get_mpi_file_sync_required_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_get_mpi_file_sync_required_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_has_feature_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_has_feature_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_has_feature_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_has_feature_event_t stats_key_v = {};
            struct hdf5_H5F_shared_has_feature_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1000;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_has_feature_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_has_feature_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_mpi_get_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_mpi_get_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_mpi_get_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_mpi_get_size_event_t stats_key_v = {};
            struct hdf5_H5F_shared_mpi_get_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1001;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_mpi_get_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_mpi_get_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_select_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_select_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_select_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_select_read_event_t stats_key_v = {};
            struct hdf5_H5F_shared_select_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1002;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_select_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_select_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_select_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_select_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_select_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_select_write_event_t stats_key_v = {};
            struct hdf5_H5F_shared_select_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1003;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_select_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_select_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_vector_read_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_vector_read_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_vector_read_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_vector_read_event_t stats_key_v = {};
            struct hdf5_H5F_shared_vector_read_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1004;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_vector_read_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_vector_read_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_shared_vector_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_shared_vector_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_shared_vector_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_shared_vector_write_event_t stats_key_v = {};
            struct hdf5_H5F_shared_vector_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1005;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_shared_vector_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_shared_vector_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_sieve_buf_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_sieve_buf_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_sieve_buf_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_sieve_buf_size_event_t stats_key_v = {};
            struct hdf5_H5F_sieve_buf_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1006;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_sieve_buf_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_sieve_buf_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_sizeof_addr_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_sizeof_addr_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_sizeof_addr_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_sizeof_addr_event_t stats_key_v = {};
            struct hdf5_H5F_sizeof_addr_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1007;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_sizeof_addr_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_sizeof_addr_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_sizeof_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_sizeof_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_sizeof_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_sizeof_size_event_t stats_key_v = {};
            struct hdf5_H5F_sizeof_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1008;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_sizeof_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_sizeof_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_start_mdc_log_on_access_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_start_mdc_log_on_access_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_start_mdc_log_on_access_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_start_mdc_log_on_access_event_t stats_key_v = {};
            struct hdf5_H5F_start_mdc_log_on_access_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1009;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_start_mdc_log_on_access_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_start_mdc_log_on_access_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_store_msg_crt_idx_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_store_msg_crt_idx_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_store_msg_crt_idx_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_store_msg_crt_idx_event_t stats_key_v = {};
            struct hdf5_H5F_store_msg_crt_idx_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1010;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_store_msg_crt_idx_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_store_msg_crt_idx_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_super_dirty_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_super_dirty_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_super_dirty_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_super_dirty_event_t stats_key_v = {};
            struct hdf5_H5F_super_dirty_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1011;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_super_dirty_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_super_dirty_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_sym_leaf_k_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_sym_leaf_k_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_sym_leaf_k_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_sym_leaf_k_event_t stats_key_v = {};
            struct hdf5_H5F_sym_leaf_k_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1012;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_sym_leaf_k_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_sym_leaf_k_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_term_package_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_term_package_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_term_package_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_term_package_event_t stats_key_v = {};
            struct hdf5_H5F_term_package_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1013;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_term_package_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_term_package_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_track_metadata_read_retries_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_track_metadata_read_retries_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_track_metadata_read_retries_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_track_metadata_read_retries_event_t stats_key_v = {};
            struct hdf5_H5F_track_metadata_read_retries_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1014;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_track_metadata_read_retries_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_track_metadata_read_retries_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_traverse_mount_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_traverse_mount_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_traverse_mount_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_traverse_mount_event_t stats_key_v = {};
            struct hdf5_H5F_traverse_mount_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1015;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_traverse_mount_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_traverse_mount_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_try_close_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_try_close_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_try_close_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_try_close_event_t stats_key_v = {};
            struct hdf5_H5F_try_close_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1016;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_try_close_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_try_close_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_unmount_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_unmount_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_unmount_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_unmount_event_t stats_key_v = {};
            struct hdf5_H5F_unmount_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1017;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_unmount_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_unmount_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_use_mdc_logging_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_use_mdc_logging_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_use_mdc_logging_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_use_mdc_logging_event_t stats_key_v = {};
            struct hdf5_H5F_use_mdc_logging_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1018;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_use_mdc_logging_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_use_mdc_logging_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5F_use_tmp_space_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5F_use_tmp_space_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5F_use_tmp_space_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5F_use_tmp_space_event_t stats_key_v = {};
            struct hdf5_H5F_use_tmp_space_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1019;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5F_use_tmp_space_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5F_use_tmp_space_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fclear_elink_file_cache_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fclear_elink_file_cache_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fclear_elink_file_cache_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fclear_elink_file_cache_event_t stats_key_v = {};
            struct hdf5_H5Fclear_elink_file_cache_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1020;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fclear_elink_file_cache_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fclear_elink_file_cache_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fclose_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fclose_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fclose_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fclose_event_t stats_key_v = {};
            struct hdf5_H5Fclose_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1021;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fclose_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fclose_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fclose_async_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fclose_async_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fclose_async_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fclose_async_event_t stats_key_v = {};
            struct hdf5_H5Fclose_async_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1022;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fclose_async_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fclose_async_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fcreate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fcreate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fcreate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fcreate_event_t stats_key_v = {};
            struct hdf5_H5Fcreate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1023;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fcreate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fcreate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fcreate_async_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fcreate_async_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fcreate_async_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fcreate_async_event_t stats_key_v = {};
            struct hdf5_H5Fcreate_async_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1024;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fcreate_async_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fcreate_async_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fdelete_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fdelete_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fdelete_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fdelete_event_t stats_key_v = {};
            struct hdf5_H5Fdelete_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1025;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fdelete_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fdelete_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fflush_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fflush_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fflush_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fflush_event_t stats_key_v = {};
            struct hdf5_H5Fflush_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1026;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fflush_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fflush_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fflush_async_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fflush_async_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fflush_async_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fflush_async_event_t stats_key_v = {};
            struct hdf5_H5Fflush_async_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1027;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fflush_async_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fflush_async_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fformat_convert_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fformat_convert_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fformat_convert_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fformat_convert_event_t stats_key_v = {};
            struct hdf5_H5Fformat_convert_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1028;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fformat_convert_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fformat_convert_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_access_plist_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_access_plist_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_access_plist_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_access_plist_event_t stats_key_v = {};
            struct hdf5_H5Fget_access_plist_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1029;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_access_plist_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_access_plist_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_create_plist_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_create_plist_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_create_plist_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_create_plist_event_t stats_key_v = {};
            struct hdf5_H5Fget_create_plist_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1030;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_create_plist_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_create_plist_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_dset_no_attrs_hint_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_dset_no_attrs_hint_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_dset_no_attrs_hint_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_dset_no_attrs_hint_event_t stats_key_v = {};
            struct hdf5_H5Fget_dset_no_attrs_hint_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1031;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_dset_no_attrs_hint_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_dset_no_attrs_hint_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_eoa_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_eoa_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_eoa_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_eoa_event_t stats_key_v = {};
            struct hdf5_H5Fget_eoa_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1032;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_eoa_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_eoa_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_file_image_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_file_image_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_file_image_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_file_image_event_t stats_key_v = {};
            struct hdf5_H5Fget_file_image_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1033;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_file_image_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_file_image_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_fileno_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_fileno_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_fileno_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_fileno_event_t stats_key_v = {};
            struct hdf5_H5Fget_fileno_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1034;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_fileno_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_fileno_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_filesize_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_filesize_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_filesize_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_filesize_event_t stats_key_v = {};
            struct hdf5_H5Fget_filesize_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1035;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_filesize_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_filesize_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_free_sections_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_free_sections_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_free_sections_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_free_sections_event_t stats_key_v = {};
            struct hdf5_H5Fget_free_sections_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1036;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_free_sections_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_free_sections_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_freespace_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_freespace_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_freespace_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_freespace_event_t stats_key_v = {};
            struct hdf5_H5Fget_freespace_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1037;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_freespace_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_freespace_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_info1_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_info1_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_info1_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_info1_event_t stats_key_v = {};
            struct hdf5_H5Fget_info1_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1038;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_info1_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_info1_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_info2_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_info2_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_info2_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_info2_event_t stats_key_v = {};
            struct hdf5_H5Fget_info2_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1039;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_info2_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_info2_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_intent_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_intent_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_intent_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_intent_event_t stats_key_v = {};
            struct hdf5_H5Fget_intent_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1040;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_intent_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_intent_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_mdc_config_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_mdc_config_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_mdc_config_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_mdc_config_event_t stats_key_v = {};
            struct hdf5_H5Fget_mdc_config_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1041;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_mdc_config_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_mdc_config_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_mdc_hit_rate_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_mdc_hit_rate_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_mdc_hit_rate_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_mdc_hit_rate_event_t stats_key_v = {};
            struct hdf5_H5Fget_mdc_hit_rate_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1042;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_mdc_hit_rate_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_mdc_hit_rate_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_mdc_image_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_mdc_image_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_mdc_image_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_mdc_image_info_event_t stats_key_v = {};
            struct hdf5_H5Fget_mdc_image_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1043;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_mdc_image_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_mdc_image_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_mdc_logging_status_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_mdc_logging_status_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_mdc_logging_status_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_mdc_logging_status_event_t stats_key_v = {};
            struct hdf5_H5Fget_mdc_logging_status_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1044;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_mdc_logging_status_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_mdc_logging_status_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_mdc_size_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_mdc_size_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_mdc_size_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_mdc_size_event_t stats_key_v = {};
            struct hdf5_H5Fget_mdc_size_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1045;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_mdc_size_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_mdc_size_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_metadata_read_retry_info_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_metadata_read_retry_info_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_metadata_read_retry_info_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_metadata_read_retry_info_event_t stats_key_v = {};
            struct hdf5_H5Fget_metadata_read_retry_info_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1046;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_metadata_read_retry_info_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_metadata_read_retry_info_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_mpi_atomicity_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_mpi_atomicity_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_mpi_atomicity_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_mpi_atomicity_event_t stats_key_v = {};
            struct hdf5_H5Fget_mpi_atomicity_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1047;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_mpi_atomicity_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_mpi_atomicity_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_name_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_name_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_name_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_name_event_t stats_key_v = {};
            struct hdf5_H5Fget_name_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1048;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_name_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_name_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_obj_count_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_obj_count_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_obj_count_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_obj_count_event_t stats_key_v = {};
            struct hdf5_H5Fget_obj_count_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1049;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_obj_count_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_obj_count_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_obj_ids_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_obj_ids_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_obj_ids_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_obj_ids_event_t stats_key_v = {};
            struct hdf5_H5Fget_obj_ids_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1050;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_obj_ids_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_obj_ids_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_page_buffering_stats_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_page_buffering_stats_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_page_buffering_stats_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_page_buffering_stats_event_t stats_key_v = {};
            struct hdf5_H5Fget_page_buffering_stats_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1051;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_page_buffering_stats_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_page_buffering_stats_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fget_vfd_handle_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fget_vfd_handle_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fget_vfd_handle_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fget_vfd_handle_event_t stats_key_v = {};
            struct hdf5_H5Fget_vfd_handle_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1052;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fget_vfd_handle_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fget_vfd_handle_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fincrement_filesize_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fincrement_filesize_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fincrement_filesize_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fincrement_filesize_event_t stats_key_v = {};
            struct hdf5_H5Fincrement_filesize_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1053;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fincrement_filesize_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fincrement_filesize_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fis_accessible_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fis_accessible_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fis_accessible_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fis_accessible_event_t stats_key_v = {};
            struct hdf5_H5Fis_accessible_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1054;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fis_accessible_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fis_accessible_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fis_hdf5_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fis_hdf5_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fis_hdf5_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fis_hdf5_event_t stats_key_v = {};
            struct hdf5_H5Fis_hdf5_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1055;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fis_hdf5_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fis_hdf5_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fmount_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fmount_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fmount_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fmount_event_t stats_key_v = {};
            struct hdf5_H5Fmount_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1056;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fmount_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fmount_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fopen_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fopen_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fopen_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fopen_event_t stats_key_v = {};
            struct hdf5_H5Fopen_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1057;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fopen_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fopen_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fopen_async_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fopen_async_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fopen_async_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fopen_async_event_t stats_key_v = {};
            struct hdf5_H5Fopen_async_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1058;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fopen_async_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fopen_async_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Freopen_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Freopen_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Freopen_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Freopen_event_t stats_key_v = {};
            struct hdf5_H5Freopen_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1059;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Freopen_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Freopen_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Freopen_async_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Freopen_async_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Freopen_async_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Freopen_async_event_t stats_key_v = {};
            struct hdf5_H5Freopen_async_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1060;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Freopen_async_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Freopen_async_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Freset_mdc_hit_rate_stats_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Freset_mdc_hit_rate_stats_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Freset_mdc_hit_rate_stats_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Freset_mdc_hit_rate_stats_event_t stats_key_v = {};
            struct hdf5_H5Freset_mdc_hit_rate_stats_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1061;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Freset_mdc_hit_rate_stats_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Freset_mdc_hit_rate_stats_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Freset_page_buffering_stats_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Freset_page_buffering_stats_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Freset_page_buffering_stats_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Freset_page_buffering_stats_event_t stats_key_v = {};
            struct hdf5_H5Freset_page_buffering_stats_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1062;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Freset_page_buffering_stats_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Freset_page_buffering_stats_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fset_dset_no_attrs_hint_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fset_dset_no_attrs_hint_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fset_dset_no_attrs_hint_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fset_dset_no_attrs_hint_event_t stats_key_v = {};
            struct hdf5_H5Fset_dset_no_attrs_hint_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1063;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fset_dset_no_attrs_hint_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fset_dset_no_attrs_hint_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fset_latest_format_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fset_latest_format_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fset_latest_format_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fset_latest_format_event_t stats_key_v = {};
            struct hdf5_H5Fset_latest_format_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1064;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fset_latest_format_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fset_latest_format_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fset_libver_bounds_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fset_libver_bounds_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fset_libver_bounds_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fset_libver_bounds_event_t stats_key_v = {};
            struct hdf5_H5Fset_libver_bounds_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1065;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fset_libver_bounds_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fset_libver_bounds_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fset_mdc_config_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fset_mdc_config_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fset_mdc_config_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fset_mdc_config_event_t stats_key_v = {};
            struct hdf5_H5Fset_mdc_config_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1066;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fset_mdc_config_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fset_mdc_config_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fset_mpi_atomicity_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fset_mpi_atomicity_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fset_mpi_atomicity_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fset_mpi_atomicity_event_t stats_key_v = {};
            struct hdf5_H5Fset_mpi_atomicity_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1067;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fset_mpi_atomicity_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fset_mpi_atomicity_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fstart_mdc_logging_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fstart_mdc_logging_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fstart_mdc_logging_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fstart_mdc_logging_event_t stats_key_v = {};
            struct hdf5_H5Fstart_mdc_logging_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1068;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fstart_mdc_logging_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fstart_mdc_logging_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fstart_swmr_write_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fstart_swmr_write_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fstart_swmr_write_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fstart_swmr_write_event_t stats_key_v = {};
            struct hdf5_H5Fstart_swmr_write_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1069;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fstart_swmr_write_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fstart_swmr_write_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Fstop_mdc_logging_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Fstop_mdc_logging_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Fstop_mdc_logging_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Fstop_mdc_logging_event_t stats_key_v = {};
            struct hdf5_H5Fstop_mdc_logging_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1070;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Fstop_mdc_logging_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Fstop_mdc_logging_event_t), 0);
        
            return 0;
        }
        
        
        
            struct hdf5_H5Funmount_event_t {                                                       
            u64 id;
            u64 event_id;
            u64 ip;
            u64 ts;                                                                   
            u64 dur;
            
            
        };
        
        
        int trace_hdf5_H5Funmount_entry(struct pt_regs *ctx ) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t fn = {};
            fn.ts = bpf_ktime_get_ns();
            fn.ip = PT_REGS_IP(ctx);
            // bpf_trace_printk("Tracing IP \%d",fn.ip);
            fn_pid_map.update(&key, &fn);
                    
                        
            return 0;
        }

        int trace_hdf5_H5Funmount_exit(struct pt_regs *ctx) {
            
            u64 id = bpf_get_current_pid_tgid();
            u32 pid = id;
            u64* start_ts = pid_map.lookup(&pid);
            if (start_ts == 0 || pid == 0)                                      
                return 0;
                    
            
            struct fn_key_t key = {};
            key.id = id;
            struct fn_t *fn = fn_pid_map.lookup(&key);
            if (fn == 0) return 0; // missed entry
                    
            
            struct hdf5_H5Funmount_event_t stats_key_v = {};
            struct hdf5_H5Funmount_event_t *stats_key = &stats_key_v;
            stats_key->id = id;
            stats_key->event_id = 1071;
            stats_key->ip = fn->ip;
                    
                        
                        
            struct hdf5_H5Funmount_event_t* stats = stats_key;
            stats->ts = (fn->ts  - *start_ts);
            stats->dur = bpf_ktime_get_ns() - fn->ts;
                    
                       
            // bpf_trace_printk("Submitting CUSTOM TRACE IP \%d",fn->ip); 
            
            events.ringbuf_output(&stats_key_v, sizeof(struct hdf5_H5Funmount_event_t), 0);
        
            return 0;
        }
        